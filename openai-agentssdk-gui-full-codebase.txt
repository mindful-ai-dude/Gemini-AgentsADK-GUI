Directory structure:
‚îî‚îÄ‚îÄ jgravelle-openai-agentssdk-gui/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ CHANGELOG.md
    ‚îú‚îÄ‚îÄ CODE_OF_CONDUCT.md
    ‚îú‚îÄ‚îÄ config-overrides.js
    ‚îú‚îÄ‚îÄ CONTRIBUTING.md
    ‚îú‚îÄ‚îÄ LICENSE
    ‚îú‚îÄ‚îÄ OpenAI-Agents SDK Reference Guide.md
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ SECURITY.md
    ‚îú‚îÄ‚îÄ test-agent.bat
    ‚îú‚îÄ‚îÄ webpack.config.js
    ‚îú‚îÄ‚îÄ docs/
    ‚îÇ   ‚îú‚îÄ‚îÄ deployment.md
    ‚îÇ   ‚îú‚îÄ‚îÄ example-agents.md
    ‚îÇ   ‚îú‚îÄ‚îÄ faq.md
    ‚îÇ   ‚îú‚îÄ‚îÄ getting-started.md
    ‚îÇ   ‚îî‚îÄ‚îÄ index.md
    ‚îú‚îÄ‚îÄ public/
    ‚îÇ   ‚îú‚îÄ‚îÄ index.html
    ‚îÇ   ‚îî‚îÄ‚îÄ manifest.json
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ App.js
    ‚îÇ   ‚îú‚îÄ‚îÄ index.js
    ‚îÇ   ‚îú‚îÄ‚îÄ test-agent-api.js
    ‚îÇ   ‚îú‚îÄ‚îÄ components/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AgentBuilder.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AgentTester.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ApiKeySetup.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Navbar.js
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ builder/
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ BasicDetails.js
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CodePreview.js
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ GuardrailsConfigurator.js
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ HandoffsSelector.js
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ InstructionsEditor.js
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ TestAgent.js
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ToolsSelector.js
    ‚îÇ   ‚îú‚îÄ‚îÄ styles/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.css
    ‚îÇ   ‚îî‚îÄ‚îÄ utils/
    ‚îÇ       ‚îú‚îÄ‚îÄ apiService.js
    ‚îÇ       ‚îú‚îÄ‚îÄ codeTemplates.js
    ‚îÇ       ‚îú‚îÄ‚îÄ modelOptions.js
    ‚îÇ       ‚îî‚îÄ‚îÄ tools.js
    ‚îî‚îÄ‚îÄ .github/
        ‚îú‚îÄ‚îÄ ISSUE_TEMPLATE/
        ‚îÇ   ‚îú‚îÄ‚îÄ bug_report.md
        ‚îÇ   ‚îî‚îÄ‚îÄ feature_request.md
        ‚îî‚îÄ‚îÄ PULL_REQUEST_TEMPLATE/
            ‚îî‚îÄ‚îÄ pull_request_template.md

================================================
FILE: README.md
================================================
# OpenAI Agent Builder GUI

![OpenAI Agent Builder GUI](https://img.shields.io/badge/OpenAI-Agent%20Builder-10A37F?style=for-the-badge&logo=openai&logoColor=white)
![React](https://img.shields.io/badge/React-18.2.0-61DAFB?style=for-the-badge&logo=react&logoColor=white)
![Material UI](https://img.shields.io/badge/Material%20UI-5.15.0-0081CB?style=for-the-badge&logo=mui&logoColor=white)
![License](https://img.shields.io/badge/License-MIT-yellow.svg?style=for-the-badge)

A professional, intuitive, and streamlined GUI application for creating, testing, and managing OpenAI agents using the OpenAI Agents SDK. Build powerful AI agents with custom tools, handoffs, and guardrails without writing code.

> **IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.

## üåü Features

### Agent Creation & Management
- **Intuitive Agent Builder**: Step-by-step wizard interface for creating agents
- **Visual Tool Configuration**: Add and configure tools with a user-friendly interface
- **Agent Dashboard**: Manage all your agents in one place
- **Clone & Edit**: Easily duplicate and modify existing agents

### Advanced Capabilities
- **Custom Instructions**: Create detailed system prompts for your agents
- **Model Selection**: Choose from OpenAI's latest models including GPT-4o
- **Tool Integration**: Add web search, file search, and custom function tools
- **Agent Handoffs**: Configure specialist agents for delegation
- **Guardrails**: Set up input and output validation mechanisms

### Testing & Deployment
- **Built-in Test Environment**: Test your agents directly in the application
- **Real-time Chat Interface**: Interact with your agents and see tool usage
- **Code Generation**: Automatically generate Python code for the OpenAI Agents SDK
- **Export Options**: Download or copy code for use in your applications

### User Experience
- **Dark/Light Mode**: Toggle between dark and light themes
- **Responsive Design**: Works on desktop and tablet devices
- **Local Storage**: Agents are saved locally for privacy and convenience
- **API Key Management**: Securely store and validate your OpenAI API key

## üöÄ Getting Started

### Prerequisites

- Node.js (v14.x or higher)
- npm (v6.x or higher)
- OpenAI API key

### Installation

1. Clone the repository
```bash
git clone https://github.com/yourusername/openai-agent-builder.git
cd openai-agent-builder
```

2. Install dependencies
```bash
npm install
```

3. Start the development server
```bash
npm start
```

4. Open your browser and navigate to `http://localhost:3000`

### Building for Production

To create a production build:

```bash
npm run build
```

The build files will be created in the `build/` directory and can be served using any static file server.

## üìñ Usage Guide

### Setting Up Your API Key

1. When you first launch the application, you'll be prompted to enter your OpenAI API key
2. Your API key is stored locally in your browser and is never sent to our servers
3. You can test your API key with the included test script:
   ```bash
   ./test-agent.bat
   ```

### Creating Your First Agent

1. Click the "Create Agent" button on the dashboard
2. Follow the step-by-step wizard:
   - **Basic Details**: Set name, description, and model
   - **Instructions**: Define your agent's system prompt
   - **Tools**: Add capabilities like web search or custom functions
   - **Handoffs**: Configure specialist agents for delegation
   - **Guardrails**: Set up input and output validation
   - **Code Preview**: View and export the generated code
   - **Test Agent**: Try out your agent in a chat interface

### Testing Your Agent

1. Use the built-in test environment to interact with your agent
2. See how your agent responds to different inputs
3. Observe tool usage and handoffs in real-time
4. Refine your agent based on test results

### Deploying Your Agent

1. Generate Python code for your agent using the Code Preview tab
2. Copy or download the code
3. Use the code in your own applications with the OpenAI Agents SDK
4. Follow the OpenAI Agents SDK documentation for advanced usage

## üèóÔ∏è Architecture

This application follows the OpenAI Agents SDK architecture as outlined in the OpenAI Agents SDK Reference Guide. The key components include:

### Core Components

- **Agent**: Core component for defining agents with instructions, tools, and other capabilities
- **Runner**: Used for executing agents with user inputs
- **Tools**: Function tools, web search, file search, and other capabilities
- **Handoffs**: Delegation to specialist agents for specific tasks
- **Guardrails**: Input and output validation mechanisms
- **Tracing**: Monitoring and debugging agent execution

### Application Structure

- **React Frontend**: Built with React and Material UI for a responsive user interface
- **Local Storage**: Agents and settings are stored in browser local storage
- **OpenAI API Integration**: Direct integration with OpenAI's API for agent execution
- **Code Generation**: Templates for generating Python code for the OpenAI Agents SDK

## üîß Implementation Details

The application uses the following key components:

- **apiService.js**: Core service that interfaces with the OpenAI Agents SDK
- **AgentBuilder.js**: Multi-step form for creating and configuring agents
- **TestAgent.js**: Testing environment that uses the SDK to run agents
- **CodePreview.js**: Generates Python code for using the agents in your own applications
- **Dashboard.js**: Manages the list of agents and provides CRUD operations

## ü§ù Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## üìÑ License

This project is licensed under the MIT License - see the LICENSE file for details.

## üôè Acknowledgments

- Built with React and Material UI
- Powered by the OpenAI Agents SDK
- Inspired by the growing need for accessible AI agent creation tools

## üîó Links

- [OpenAI Agents SDK Documentation](https://platform.openai.com/docs/agents)
- [React Documentation](https://reactjs.org/)
- [Material UI Documentation](https://mui.com/)

---

<p align="center">
  <i>Build powerful AI agents without writing code</i><br>
  <a href="https://github.com/yourusername/openai-agent-builder/issues">Report Bug</a> ¬∑
  <a href="https://github.com/yourusername/openai-agent-builder/issues">Request Feature</a>
</p>


================================================
FILE: CHANGELOG.md
================================================
# Changelog

All notable changes to the OpenAI Agent Builder GUI will be documented in this file.

**IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Initial project structure and documentation

## [0.1.0] - 2025-03-16

### Added
- Initial release of the OpenAI Agent Builder GUI
- Dashboard for managing agents
- Multi-step agent creation wizard
- Visual tool configuration
- Agent handoff management
- Guardrails configuration
- Code generation for the OpenAI Agents SDK
- Test environment for agents
- Dark/light mode toggle
- Local storage for agent configurations
- API key management and validation
- Responsive design for desktop and tablet

### Security
- API keys stored locally in browser localStorage
- No server-side storage of sensitive information


================================================
FILE: CODE_OF_CONDUCT.md
================================================
# Contributor Covenant Code of Conduct

## Our Pledge

We pledge to make participation in our project and community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment include:
* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior include:
* The use of sexualized language or imagery and unwelcome sexual attention or advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information without explicit permission
* Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project maintainer, J. Gravelle, at j@gravelle.us. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org), version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

---

**IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.


================================================
FILE: config-overrides.js
================================================
module.exports = function override(config, env) {
  // Add polyfills for Node.js core modules
  config.resolve.fallback = {
    ...config.resolve.fallback,
    "path": require.resolve("path-browserify"),
    "fs": false,
    "fs/promises": false
  };
  
  return config;
};


================================================
FILE: CONTRIBUTING.md
================================================
# Contributing to OpenAI Agent Builder GUI

Thank you for considering contributing to the OpenAI Agent Builder GUI! This document provides guidelines and instructions for contributing to this project.

**IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.

## Code of Conduct

By participating in this project, you agree to abide by our Code of Conduct. Please be respectful, inclusive, and considerate in all interactions.

## How Can I Contribute?

### Reporting Bugs

If you find a bug, please create an issue with the following information:

- A clear, descriptive title
- Steps to reproduce the issue
- Expected behavior
- Actual behavior
- Screenshots (if applicable)
- Environment details (browser, OS, etc.)

### Suggesting Enhancements

We welcome suggestions for enhancements! Please create an issue with:

- A clear, descriptive title
- A detailed description of the proposed enhancement
- Any relevant examples, mockups, or references
- Why this enhancement would be useful to most users

### Pull Requests

1. Fork the repository
2. Create a new branch (`git checkout -b feature/amazing-feature`)
3. Make your changes
4. Run tests to ensure your changes don't break existing functionality
5. Commit your changes (`git commit -m 'Add some amazing feature'`)
6. Push to the branch (`git push origin feature/amazing-feature`)
7. Open a Pull Request

## Development Setup

1. Clone the repository
```bash
git clone https://github.com/yourusername/openai-agent-builder.git
cd openai-agent-builder
```

2. Install dependencies
```bash
npm install
```

3. Start the development server
```bash
npm start
```

## Coding Guidelines

### JavaScript/React

- Follow the existing code style
- Use functional components with hooks
- Add comments for complex logic
- Keep components small and focused on a single responsibility
- Use meaningful variable and function names

### CSS/Styling

- Use Material UI components and styling system
- Maintain consistent spacing and sizing
- Ensure responsive design works on various screen sizes

### Testing

- Write tests for new features
- Ensure all tests pass before submitting a PR
- Test on different browsers if making UI changes

## Documentation

- Update the README.md if you change functionality
- Document new features, props, and components
- Include JSDoc comments for functions and components

## Review Process

All submissions require review. We use GitHub pull requests for this purpose.

1. A maintainer will review your PR
2. They may ask for changes or improvements
3. Once approved, your PR will be merged
4. Your contribution will be acknowledged in the project

## Thank You!

Your contributions are what make the open-source community such an amazing place to learn, inspire, and create. We appreciate your efforts to improve this project!


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 J. Gravelle (https://j.gravelle.us | j@gravelle.us)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
FILE: OpenAI-Agents SDK Reference Guide.md
================================================
# OpenAI Agents SDK Reference Guide

## Installation & Setup
```python
pip install openai-agents
export OPENAI_API_KEY=sk-...  # or set via code
```

```python
from agents import set_default_openai_key, set_default_openai_client
set_default_openai_key("your-key", use_for_tracing=True)  # If not using env var
```

## Core Components

### Agent
```python
from agents import Agent, ModelSettings

agent = Agent(
    name="MyAgent",                   # Required: Agent's name
    instructions="Your prompt here",  # Required: System prompt/instructions
    model="o3-mini",                  # Optional: Default is "gpt-4o"
    tools=[],                         # Optional: Tools the agent can use
    handoffs=[],                      # Optional: Sub-agents to delegate to
    output_type=None,                 # Optional: Structured output type
    input_guardrails=[],              # Optional: Input validation
    output_guardrails=[],             # Optional: Output validation
    hooks=None,                       # Optional: Lifecycle hooks
)
```

### Context (Generic Type Parameter)
```python
from dataclasses import dataclass

@dataclass
class UserContext:
    uid: str
    is_pro_user: bool

agent = Agent[UserContext](
    name="Contextual Agent",
    instructions="Help user based on their context",
)
```

### Structured Output
```python
from pydantic import BaseModel

class CalendarEvent(BaseModel):
    name: str
    date: str
    participants: list[str]

agent = Agent(
    name="Calendar extractor",
    instructions="Extract calendar events from text",
    output_type=CalendarEvent,  # Will use structured outputs
)
```

### Dynamic Instructions
```python
def dynamic_instructions(context, agent):
    return f"The user's name is {context.context.name}. Help them with their questions."

agent = Agent[UserContext](
    name="Dynamic Agent",
    instructions=dynamic_instructions,  # Function that returns instructions
)
```

### Cloning Agents
```python
new_agent = existing_agent.clone(
    name="New Name",
    instructions="New instructions",
)
```

## Running Agents

### Basic Runner
```python
from agents import Agent, Runner

# Async version
result = await Runner.run(agent, "Your prompt here")

# Sync version
result = Runner.run_sync(agent, "Your prompt here")

# Streaming version
stream_result = Runner.run_streamed(agent, "Your prompt here")
async for event in stream_result.stream_events():
    # Process streaming events
    pass
```

### Runner Configuration
```python
from agents import RunConfig

result = await Runner.run(
    agent, 
    "Your prompt", 
    context=your_context_object,  # Optional: Context object
    run_config=RunConfig(
        model="custom-model-override",
        model_settings=ModelSettings(temperature=0.5),
        workflow_name="My Workflow",
        trace_id="custom-trace-id",
        group_id="conversation-id",
        max_turns=10,
        tracing_disabled=False,
    )
)
```

### Conversation Management
```python
# First turn
result = await Runner.run(agent, "What's the weather?")

# Subsequent turns (preserving conversation history)
new_input = result.to_input_list() + [{"role": "user", "content": "What about tomorrow?"}]
result = await Runner.run(agent, new_input)
```

## Tools

### Function Tools
```python
from agents import function_tool

@function_tool
def get_weather(city: str) -> str:
    """Fetch weather for a city.
    
    Args:
        city: The city to get weather for.
    """
    # Implementation
    return f"The weather in {city} is sunny"

agent = Agent(
    name="Weather Bot",
    tools=[get_weather],  # Pass the decorated function
)
```

### Custom Function Tools
```python
from agents import FunctionTool
from pydantic import BaseModel

class FunctionArgs(BaseModel):
    query: str

async def search_function(ctx, args_json: str) -> str:
    args = FunctionArgs.model_validate_json(args_json)
    # Implementation
    return f"Results for {args.query}"

tool = FunctionTool(
    name="search",
    description="Search for information",
    params_json_schema=FunctionArgs.model_json_schema(),
    on_invoke_tool=search_function,
)
```

### Hosted Tools
```python
from agents import WebSearchTool, FileSearchTool

agent = Agent(
    name="Research Assistant",
    tools=[
        WebSearchTool(),
        FileSearchTool(max_num_results=3, vector_store_ids=["VECTOR_STORE_ID"]),
    ],
)
```

### Agent as Tool
```python
spanish_agent = Agent(name="Spanish Translator", instructions="Translate to Spanish")

main_agent = Agent(
    name="Translation Orchestrator",
    tools=[
        spanish_agent.as_tool(
            tool_name="translate_to_spanish",
            tool_description="Translate text to Spanish"
        ),
    ]
)
```

## Handoffs

### Basic Handoffs
```python
billing_agent = Agent(name="Billing Agent", instructions="Handle billing inquiries")
refund_agent = Agent(name="Refund Agent", instructions="Process refund requests")

triage_agent = Agent(
    name="Customer Support",
    instructions="Direct users to appropriate specialists",
    handoffs=[billing_agent, refund_agent],
)
```

### Custom Handoffs
```python
from agents import handoff, RunContextWrapper
from pydantic import BaseModel

class EscalationData(BaseModel):
    reason: str

async def on_handoff(ctx: RunContextWrapper, input_data: EscalationData):
    print(f"Escalation reason: {input_data.reason}")

handoff_obj = handoff(
    agent=specialist_agent,
    on_handoff=on_handoff,
    input_type=EscalationData,
    tool_name_override="escalate_to_specialist",
)

agent = Agent(
    name="Support Agent",
    handoffs=[handoff_obj],
)
```

### Input Filters
```python
from agents import handoff
from agents.extensions import handoff_filters

filtered_handoff = handoff(
    agent=specialist_agent,
    input_filter=handoff_filters.remove_all_tools,  # Predefined filter
)
```

## Guardrails

### Input Guardrails
```python
from agents import Agent, GuardrailFunctionOutput, InputGuardrailTripwireTriggered, input_guardrail

@input_guardrail
async def content_filter(ctx, agent, input):
    # Check input
    is_inappropriate = check_inappropriate(input)
    
    return GuardrailFunctionOutput(
        output_info={"reason": "Contains inappropriate content"},
        tripwire_triggered=is_inappropriate,
    )

agent = Agent(
    name="Protected Agent",
    instructions="Help with questions",
    input_guardrails=[content_filter],
)

# Usage with exception handling
try:
    result = await Runner.run(agent, user_input)
except InputGuardrailTripwireTriggered as e:
    print("Input guardrail was triggered:", e.guardrail_result.output_info)
```

### Output Guardrails
```python
from pydantic import BaseModel
from agents import Agent, GuardrailFunctionOutput, OutputGuardrailTripwireTriggered, output_guardrail

class MessageOutput(BaseModel):
    response: str

@output_guardrail
async def output_filter(ctx, agent, output: MessageOutput):
    # Check output
    contains_pii = check_for_pii(output.response)
    
    return GuardrailFunctionOutput(
        output_info={"reason": "Contains PII"},
        tripwire_triggered=contains_pii,
    )

agent = Agent(
    name="Secure Agent",
    instructions="Help with questions",
    output_guardrails=[output_filter],
    output_type=MessageOutput,
)
```

## Orchestration Patterns

### LLM-Driven Orchestration
```python
# Single agent with tools and handoffs
orchestrator = Agent(
    name="Orchestrator",
    instructions="Plan and execute complex tasks using available tools",
    tools=[search_tool, calculator_tool, fetch_data_tool],
    handoffs=[specialist_agent1, specialist_agent2],
)
```

### Code-Driven Orchestration
```python
# Sequential agent chain
outline_result = await Runner.run(outline_agent, "Write a blog post about climate change")
full_draft = await Runner.run(writer_agent, f"Expand this outline: {outline_result.final_output}")
final_post = await Runner.run(editor_agent, f"Edit this draft: {full_draft.final_output}")

# Parallel agents
import asyncio
results = await asyncio.gather(
    Runner.run(research_agent1, "Research topic A"),
    Runner.run(research_agent2, "Research topic B")
)

# Evaluation loop
max_attempts = 3
for i in range(max_attempts):
    result = await Runner.run(writer_agent, "Generate content")
    eval_result = await Runner.run(evaluator_agent, result.final_output)
    if eval_result.final_output.score > 0.8:
        break
```

## Tracing

### Basic Tracing
```python
from agents import trace

# Wrap multiple operations in a single trace
with trace("Workflow Name", group_id="conversation-123"):
    result1 = await Runner.run(agent1, "First query")
    result2 = await Runner.run(agent2, "Second query")
```

### Tracing Configuration
```python
from agents import set_tracing_disabled, add_trace_processor

# Disable tracing globally
set_tracing_disabled(True)

# Custom trace processor
class MyTraceProcessor(TracingProcessor):
    # Implementation

add_trace_processor(MyTraceProcessor())
```

## Result Handling

```python
result = await Runner.run(agent, "Your prompt")

# Access final output (string or structured output)
print(result.final_output)

# Access the last agent that ran
last_agent = result.last_agent

# Get input for next conversation turn
next_input = result.to_input_list() + [{"role": "user", "content": "Follow-up question"}]

# Examine generated items
for item in result.new_items:
    if item.type == "message_output_item":
        print("Agent said:", item.raw_item.content)
    elif item.type == "tool_call_item":
        print("Called tool:", item.raw_item.name)
    elif item.type == "tool_call_output_item":
        print("Tool result:", item.output)
```

## Streaming Events

```python
stream_result = Runner.run_streamed(agent, "Your prompt")

async for event in stream_result.stream_events():
    if event.type == "raw_response_event":
        # Process token-by-token (most granular)
        if hasattr(event.data, "delta"):
            print(event.data.delta, end="", flush=True)
    
    elif event.type == "run_item_stream_event":
        # Process complete items
        if event.item.type == "message_output_item":
            print("Message complete:", event.item.raw_item.content)
        elif event.item.type == "tool_call_item":
            print("Tool call:", event.item.raw_item.name)
    
    elif event.type == "agent_updated_stream_event":
        print("Agent changed to:", event.new_agent.name)
```


================================================
FILE: package.json
================================================
{
  "name": "openai-agent-builder",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.11.1",
    "@emotion/styled": "^11.11.0",
    "@monaco-editor/react": "^4.6.0",
    "@mui/icons-material": "^5.15.0",
    "@mui/material": "^5.15.0",
    "@rjsf/core": "^5.16.0",
    "@rjsf/mui": "^5.16.0",
    "@rjsf/validator-ajv8": "^5.16.0",
    "axios": "^1.6.0",
    "openai-agents": "^1.1.0",
    "path-browserify": "^1.0.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "react-scripts": "^5.0.1"
  },
  "scripts": {
    "start": "react-app-rewired start",
    "build": "react-app-rewired build",
    "test": "react-app-rewired test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "react-app-rewired": "^2.2.1"
  }
}



================================================
FILE: SECURITY.md
================================================
# Security Policy

**IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.

## Reporting a Vulnerability

We take the security of OpenAI Agent Builder GUI seriously. If you believe you've found a security vulnerability, please follow these steps:

1. **Do not disclose the vulnerability publicly** until it has been addressed by the maintainers.
2. Email details of the vulnerability to J. Gravelle at j@gravelle.us.
3. Include as much information as possible, such as:
   - A description of the vulnerability
   - Steps to reproduce
   - Potential impact
   - Suggested fixes (if any)

## Response Process

When a security vulnerability is reported, the following process will be followed:

1. The maintainers will acknowledge receipt of the vulnerability report within 48 hours.
2. The team will investigate and determine the potential impact and severity.
3. A fix will be developed and tested.
4. A new release addressing the vulnerability will be published.
5. The vulnerability will be publicly disclosed after users have had sufficient time to update.

## Supported Versions

Only the latest version of OpenAI Agent Builder GUI receives security updates. Users are encouraged to keep their installations up to date.

## Security Best Practices

When using this application:

1. **API Keys**: Never share your OpenAI API key. The application stores it locally in your browser's localStorage and never transmits it to any server other than OpenAI's API.
2. **Agent Instructions**: Be cautious about the instructions you provide to agents, especially if they might handle sensitive information.
3. **Generated Code**: Review any generated code before using it in production environments.
4. **Updates**: Keep the application updated to benefit from the latest security patches.

## Third-Party Dependencies

This project uses several third-party dependencies. We regularly update these dependencies to incorporate security fixes. If you discover a security vulnerability in one of our dependencies, please report it according to the process above.


================================================
FILE: test-agent.bat
================================================
@echo off
echo Testing OpenAI API connection...
echo.
echo This script will test if your OpenAI API key is working correctly.
echo.
set /p OPENAI_API_KEY=Enter your OpenAI API key (starts with sk-):
set /p AGENT_NAME=Enter a name for the test agent (optional, press Enter to use default):

if "%AGENT_NAME%"=="" (
  echo Using default agent name...
  node src/test-agent-api.js
) else (
  echo Testing with custom agent name...
  node src/test-agent-api.js
)

echo.
echo Test completed. Press any key to exit.
pause > nul


================================================
FILE: webpack.config.js
================================================
module.exports = {
  resolve: {
    fallback: {
      "path": require.resolve("path-browserify"),
      "fs": false,
      "fs/promises": false
    }
  }
};


================================================
FILE: docs/deployment.md
================================================
# Deployment Guide

This guide provides instructions for deploying the OpenAI Agent Builder GUI and the agents you create with it in various environments.

**IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.

## Deploying the OpenAI Agent Builder GUI

### Option 1: Static Site Hosting

The OpenAI Agent Builder GUI is a React application that can be built into static files and hosted on any static site hosting service.

1. Build the application:
```bash
npm run build
```

2. The build files will be created in the `build/` directory.

3. Deploy these files to your preferred static hosting service:
   - GitHub Pages
   - Netlify
   - Vercel
   - AWS S3 + CloudFront
   - Firebase Hosting
   - Azure Static Web Apps

### Option 2: Docker Deployment

1. Build a Docker image using the provided Dockerfile:
```bash
docker build -t openai-agent-builder .
```

2. Run the container:
```bash
docker run -p 3000:80 openai-agent-builder
```

3. Access the application at `http://localhost:3000`

### Option 3: Self-Hosted Server

1. Build the application:
```bash
npm run build
```

2. Serve the build directory using a web server like Nginx or Apache.

Example Nginx configuration:
```nginx
server {
    listen 80;
    server_name your-domain.com;
    root /path/to/build;
    index index.html;
    
    location / {
        try_files $uri $uri/ /index.html;
    }
}
```

## Deploying Agents Created with the Builder

### Option 1: Python Script

The simplest way to deploy an agent is to use the generated Python code:

1. Export the code from the Code Preview tab
2. Create a new Python file with the exported code
3. Install the OpenAI Agents SDK:
```bash
pip install openai-agents
```
4. Set your OpenAI API key:
```python
import os
os.environ["OPENAI_API_KEY"] = "your-api-key"
```
5. Run the script:
```bash
python your_agent_script.py
```

### Option 2: Web API

You can create a simple web API to expose your agent:

1. Create a Flask application:
```python
from flask import Flask, request, jsonify
from your_agent_module import agent, Runner

app = Flask(__name__)

@app.route('/api/chat', methods=['POST'])
def chat():
    data = request.json
    user_input = data.get('message', '')
    
    # Run the agent
    result = Runner.run_sync(agent, user_input)
    
    return jsonify({
        'response': result.final_output
    })

if __name__ == '__main__':
    app.run(debug=True)
```

2. Deploy the Flask application to a server or serverless platform.

### Option 3: Integration with Existing Applications

To integrate an agent into an existing application:

1. Install the OpenAI Agents SDK in your application
2. Copy the agent definition code from the Code Preview tab
3. Use the agent in your application code:

```python
# Import the agent definition
from your_agent_module import agent

# Use the agent in your application
def process_user_input(user_input):
    result = Runner.run_sync(agent, user_input)
    return result.final_output
```

## Production Considerations

### API Key Management

Never hardcode your OpenAI API key in your application code. Instead:

1. Use environment variables
2. Use a secrets management service
3. Implement proper key rotation and monitoring

### Rate Limiting and Quotas

Be aware of OpenAI's rate limits and quotas:

1. Implement retry logic with exponential backoff
2. Monitor API usage to avoid unexpected costs
3. Set up alerts for approaching quota limits

### Error Handling

Implement robust error handling:

1. Handle API errors gracefully
2. Provide fallback responses when the API is unavailable
3. Log errors for debugging and monitoring

### Monitoring and Logging

Set up monitoring and logging:

1. Log agent inputs and outputs for debugging
2. Monitor performance metrics
3. Set up alerts for critical errors

### Security Considerations

1. Validate and sanitize user inputs
2. Implement authentication and authorization
3. Use HTTPS for all API communications
4. Regularly update dependencies

## Scaling Considerations

For high-traffic applications:

1. Implement caching for common queries
2. Use a load balancer for distributing traffic
3. Consider serverless architectures for automatic scaling
4. Optimize prompt design to reduce token usage

## Cost Optimization

To optimize costs:

1. Use the most appropriate model for your use case
2. Implement caching for repeated queries
3. Optimize prompts to reduce token usage
4. Monitor and analyze API usage regularly


================================================
FILE: docs/example-agents.md
================================================
# Example Agents

This document provides examples of different types of agents you can create with the OpenAI Agent Builder GUI. Use these examples as inspiration for your own agents.

**IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.

## 1. Customer Support Agent

### Description
A customer support agent that can answer questions about products, handle returns, and escalate complex issues to human support.

### Configuration

**Basic Details:**
- Name: Customer Support Assistant
- Model: gpt-4o
- Description: Handles customer inquiries and support requests

**Instructions:**
```
You are a helpful customer support assistant for our e-commerce store. Your role is to:
1. Answer questions about our products and services
2. Help with order tracking and status updates
3. Process simple return requests
4. Provide information about our policies
5. Escalate complex issues to human support

Always be polite, professional, and empathetic. If you don't know the answer to a question, don't make up information - instead, offer to connect the customer with a human agent.
```

**Tools:**
- Web Search Tool (for looking up product information)
- Order Lookup Tool (custom function tool)
- Return Request Tool (custom function tool)

**Handoffs:**
- Human Support Specialist (for complex issues)
- Returns Department (for complicated return scenarios)

**Guardrails:**
- Input guardrail to detect abusive language
- Output guardrail to ensure responses follow company policy

## 2. Research Assistant

### Description
A research assistant that can search the web, summarize information, and generate reports on various topics.

### Configuration

**Basic Details:**
- Name: Research Assistant
- Model: gpt-4o
- Description: Helps with research tasks and information gathering

**Instructions:**
```
You are a research assistant designed to help with information gathering and synthesis. Your capabilities include:
1. Searching the web for current information
2. Summarizing articles and research papers
3. Organizing information into structured formats
4. Providing balanced perspectives on complex topics
5. Citing sources properly

Always provide balanced, factual information. When presenting controversial topics, present multiple perspectives. Always cite your sources clearly.
```

**Tools:**
- Web Search Tool
- File Search Tool
- Citation Generator Tool (custom function tool)

**Handoffs:**
- None

**Guardrails:**
- Output guardrail to ensure proper citation format
- Output guardrail to detect potential bias

## 3. Personal Finance Advisor

### Description
A financial advisor that can provide budgeting advice, investment information, and financial planning guidance.

### Configuration

**Basic Details:**
- Name: Finance Advisor
- Model: gpt-4o
- Description: Provides personal finance guidance and advice

**Instructions:**
```
You are a personal finance advisor designed to help users with financial planning, budgeting, and investment information. Your role is to:
1. Provide general financial education and advice
2. Help with budgeting and expense tracking
3. Explain investment concepts and options
4. Discuss retirement planning strategies
5. Explain tax concepts in simple terms

Always clarify that you provide general information, not personalized financial advice. Encourage users to consult with a qualified financial professional for specific investment decisions or tax advice.
```

**Tools:**
- Calculator Tool (custom function tool)
- Investment Return Calculator (custom function tool)
- Web Search Tool (for current financial information)

**Handoffs:**
- Tax Specialist (for complex tax questions)
- Investment Specialist (for detailed investment advice)

**Guardrails:**
- Output guardrail to ensure financial disclaimers are included
- Input guardrail to detect requests for specific investment recommendations

## Implementing These Examples

To implement any of these example agents:

1. Create a new agent in the OpenAI Agent Builder GUI
2. Use the configuration details provided above
3. Customize the agent to fit your specific needs
4. Test the agent thoroughly before deployment
5. Generate the code and integrate it into your application

These examples demonstrate different use cases and configurations, but the possibilities are endless. You can combine different tools, instructions, and guardrails to create agents tailored to your specific needs.


================================================
FILE: docs/faq.md
================================================
# Frequently Asked Questions (FAQ)

## General Questions

### What is the OpenAI Agent Builder GUI?
The OpenAI Agent Builder GUI is a visual interface for creating, testing, and managing AI agents using the OpenAI Agents SDK. It allows you to build powerful AI agents without writing code.

### Is this an official OpenAI tool?
No, this is a third-party tool built on top of the OpenAI Agents SDK. It is not officially affiliated with, endorsed by, or sponsored by OpenAI. This project is created and maintained by J. Gravelle (https://j.gravelle.us | j@gravelle.us) as an independent tool designed to work with the OpenAI Agents SDK.

### Is the OpenAI Agent Builder GUI free to use?
The OpenAI Agent Builder GUI itself is open-source and free to use. However, you will need an OpenAI API key to use the agents, which is a paid service from OpenAI.

## API Keys and Pricing

### Where do I get an OpenAI API key?
You can get an OpenAI API key by signing up at [https://platform.openai.com/signup](https://platform.openai.com/signup) and creating an API key in your account dashboard.

### How much does it cost to use the agents?
The cost depends on the OpenAI models you use and the number of tokens processed. You can find the current pricing on the [OpenAI pricing page](https://openai.com/pricing).

### Is my API key secure?
Yes, your API key is stored locally in your browser's localStorage and is never sent to our servers. It is only used to make direct API calls to OpenAI.

### Can I use this without an API key?
No, an OpenAI API key is required to create and test agents. The application cannot function without a valid API key.

## Features and Functionality

### What models can I use with the Agent Builder?
You can use any of the models supported by the OpenAI Agents SDK, including GPT-4o, GPT-4, and GPT-3.5 Turbo.

### What tools can I add to my agents?
You can add various tools including:
- Web Search Tool for searching the internet
- File Search Tool for searching through documents
- Custom Function Tools that you define
- And more as the OpenAI Agents SDK evolves

### Can I export my agents?
Yes, you can export your agents as Python code that uses the OpenAI Agents SDK. This code can be integrated into your own applications.

### Can I import agents from elsewhere?
Currently, the application does not support importing agents from external sources. This feature may be added in future updates.

## Technical Questions

### What technologies does the OpenAI Agent Builder GUI use?
The application is built with:
- React for the frontend
- Material UI for the component library
- Monaco Editor for code editing
- OpenAI Agents SDK for agent functionality

### Does the application work offline?
The interface itself can work offline, but creating and testing agents requires an internet connection to communicate with the OpenAI API.

### Where is my data stored?
All your agent configurations are stored locally in your browser's localStorage. Nothing is sent to external servers except the API calls to OpenAI.

### Can I self-host the OpenAI Agent Builder GUI?
Yes, you can clone the repository and run it locally or deploy it to your own server. See the [deployment guide](./deployment.md) for more information.

## Troubleshooting

### I'm getting an "Invalid API key" error
Make sure your API key is correct and has not expired. You can verify your API key in the OpenAI dashboard.

### My agent isn't working as expected
Check the following:
1. Ensure your instructions are clear and specific
2. Verify that the tools you've added are properly configured
3. Test with different inputs to understand the agent's behavior
4. Check the OpenAI status page for any service disruptions

### The application is slow or unresponsive
This could be due to:
1. Slow internet connection
2. High load on the OpenAI API
3. Browser performance issues (try clearing cache or using a different browser)

### I'm hitting rate limits with the OpenAI API
OpenAI imposes rate limits on API calls. If you're hitting these limits:
1. Implement caching for common queries
2. Add delays between requests
3. Consider upgrading your OpenAI plan for higher rate limits

## Contributing and Support

### How can I contribute to the project?
You can contribute by:
1. Submitting bug reports or feature requests on GitHub
2. Contributing code via pull requests
3. Improving documentation
4. Sharing the project with others

See the [CONTRIBUTING.md](../CONTRIBUTING.md) file for more details.

### Where can I get help if I have questions?
You can:
1. Check this FAQ and the documentation
2. Open an issue on GitHub for bugs or feature requests
3. Join our community forum for discussions
4. Reach out via email for direct support

### Are there any tutorials or examples?
Yes, check out the [example agents](./example-agents.md) documentation for inspiration and guidance on creating different types of agents.

### How do I report a security vulnerability?
Please refer to our [SECURITY.md](../SECURITY.md) file for information on reporting security vulnerabilities.


================================================
FILE: docs/getting-started.md
================================================
# Getting Started with OpenAI Agent Builder GUI

This guide will help you set up and start using the OpenAI Agent Builder GUI to create, test, and deploy AI agents.

**IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.

## Prerequisites

Before you begin, ensure you have the following:

- Node.js (v14.x or higher)
- npm (v6.x or higher)
- An OpenAI API key with access to the latest models

## Installation

### Option 1: Clone from GitHub

1. Clone the repository:
```bash
git clone https://github.com/yourusername/openai-agent-builder.git
cd openai-agent-builder
```

2. Install dependencies:
```bash
npm install
```

3. Start the development server:
```bash
npm start
```

4. Open your browser and navigate to `http://localhost:3000`

### Option 2: Use the Hosted Version

Visit [https://openai-agent-builder.example.com](https://openai-agent-builder.example.com) to use the hosted version without installation.

## Setting Up Your API Key

1. When you first launch the application, you'll be prompted to enter your OpenAI API key
2. Enter your API key (starts with `sk-`)
3. The key will be validated and stored locally in your browser
4. You can update or change your API key later in the settings

## Creating Your First Agent

### Step 1: Basic Details

1. From the dashboard, click "Create Agent"
2. Enter a name and description for your agent
3. Select a model (GPT-4o recommended for best performance)
4. Click "Next"

### Step 2: Instructions

1. Enter detailed instructions for your agent
2. These instructions act as the system prompt that guides your agent's behavior
3. Be specific about the agent's role, tone, and limitations
4. Click "Next"

### Step 3: Tools

1. Select tools your agent can use:
   - Web Search: Allow your agent to search the web for information
   - File Search: Enable searching through documents
   - Custom Functions: Define custom tools with parameters
2. Configure each tool's parameters
3. Click "Next"

### Step 4: Handoffs

1. Configure specialist agents that your main agent can delegate to
2. Define when and how handoffs should occur
3. Click "Next"

### Step 5: Guardrails

1. Set up input guardrails to validate user inputs
2. Configure output guardrails to ensure appropriate responses
3. Click "Next"

### Step 6: Code Preview

1. Review the generated Python code for your agent
2. Copy or download the code for use in your applications
3. Click "Next"

### Step 7: Test Agent

1. Test your agent with different inputs
2. Observe how it uses tools and responds to queries
3. Save your agent when satisfied

## Next Steps

- Explore the [OpenAI Agents SDK Documentation](https://platform.openai.com/docs/agents) for advanced usage
- Check out our [example agents](./example-agents.md) for inspiration
- Learn about [deployment options](./deployment.md) for production use

## Troubleshooting

If you encounter issues:

1. Ensure your API key is valid and has sufficient quota
2. Check that you're using a supported browser (Chrome, Firefox, Safari, Edge)
3. Clear your browser cache if you experience UI issues
4. See our [FAQ](./faq.md) for common questions and answers

## Getting Help

- Open an issue on GitHub for bugs or feature requests
- Join our community forum for discussions and support
- Check the [documentation](./index.md) for detailed guides


================================================
FILE: docs/index.md
================================================
# OpenAI Agent Builder GUI Documentation

Welcome to the official documentation for the OpenAI Agent Builder GUI. This documentation will help you get started with creating, testing, and deploying AI agents using our intuitive graphical interface.

**IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.

## Table of Contents

### Getting Started
- [Installation Guide](./getting-started.md#installation)
- [Setting Up Your API Key](./getting-started.md#setting-up-your-api-key)
- [Creating Your First Agent](./getting-started.md#creating-your-first-agent)
- [Troubleshooting](./getting-started.md#troubleshooting)

### Core Concepts
- [Understanding Agents](./core-concepts/agents.md)
- [Working with Tools](./core-concepts/tools.md)
- [Agent Handoffs](./core-concepts/handoffs.md)
- [Guardrails](./core-concepts/guardrails.md)

### Advanced Usage
- [Custom Function Tools](./advanced/custom-tools.md)
- [Structured Output](./advanced/structured-output.md)
- [Conversation Management](./advanced/conversation-management.md)
- [Deployment Strategies](./advanced/deployment.md)

### API Reference
- [OpenAI Agents SDK](./api/sdk-reference.md)
- [Code Generation](./api/code-generation.md)

### Contributing
- [Development Setup](./contributing/development-setup.md)
- [Code Style Guide](./contributing/code-style.md)
- [Testing](./contributing/testing.md)
- [Documentation](./contributing/documentation.md)

## About This Documentation

This documentation is designed to be comprehensive yet accessible. If you find any issues or have suggestions for improvement, please open an issue on our GitHub repository.

## Additional Resources

- [GitHub Repository](https://github.com/yourusername/openai-agent-builder)
- [OpenAI Documentation](https://platform.openai.com/docs)
- [Community Forum](https://community.example.com/openai-agent-builder)
- [Video Tutorials](https://www.youtube.com/channel/example)

## License

OpenAI Agent Builder GUI is licensed under the MIT License. See the [LICENSE](../LICENSE) file for details.


================================================
FILE: public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#10A37F" />
    <meta
      name="description"
      content="OpenAI Agent Builder - Create and manage AI agents easily"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <title>OpenAI Agent Builder</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>


================================================
FILE: public/manifest.json
================================================
{
  "short_name": "Agent Builder",
  "name": "OpenAI Agent Builder",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#10A37F",
  "background_color": "#F7F7F8"
}


================================================
FILE: src/App.js
================================================
import React, { useState, useMemo, useEffect } from 'react';
import { Routes, Route } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import Dashboard from './components/Dashboard';
import AgentBuilder from './components/AgentBuilder';
import AgentTester from './components/AgentTester';
import Navbar from './components/Navbar';
import ApiKeySetup from './components/ApiKeySetup';

function App() {
  const [apiKeySet, setApiKeySet] = useState(false);
  const [darkMode, setDarkMode] = useState(() => {
    // Check local storage for saved preference
    const savedMode = localStorage.getItem('darkMode');
    return savedMode === 'true';
  });

  // Save dark mode preference to local storage when it changes
  useEffect(() => {
    localStorage.setItem('darkMode', darkMode);
  }, [darkMode]);

  // Create theme based on dark mode preference
  const theme = useMemo(() => 
    createTheme({
      palette: {
        mode: darkMode ? 'dark' : 'light',
        primary: {
          main: '#10A37F',
        },
        secondary: {
          main: '#0D8A6F',
        },
        background: {
          default: darkMode ? '#121212' : '#F7F7F8',
          paper: darkMode ? '#1E1E1E' : '#FFFFFF',
        },
      },
      typography: {
        fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
      },
      shape: {
        borderRadius: 8,
      },
    }), [darkMode]);

  if (!apiKeySet) {
    return (
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <ApiKeySetup onApiKeySet={() => setApiKeySet(true)} />
      </ThemeProvider>
    );
  }

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Navbar darkMode={darkMode} toggleDarkMode={() => setDarkMode(!darkMode)} />
      <Routes>
        <Route path="/" element={<Dashboard />} />
        <Route path="/build" element={<AgentBuilder />} />
        <Route path="/build/:agentId" element={<AgentBuilder />} />
        <Route path="/test/:agentId" element={<AgentTester />} />
      </Routes>
    </ThemeProvider>
  );
}

export default App;


================================================
FILE: src/index.js
================================================
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './styles/index.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);


================================================
FILE: src/test-agent-api.js
================================================
// Simple test script to verify that the OpenAI API is working properly
const { OpenAI } = require('openai-agents');

// Configuration
const API_KEY = process.env.OPENAI_API_KEY || 'your-api-key-here';
const AGENT_NAME = process.env.AGENT_NAME || 'Test Agent';

async function testOpenAI() {
  try {
    console.log('Testing OpenAI API...');
    
    // Create OpenAI client
    console.log('Setting up OpenAI client...');
    const openai = new OpenAI({
      apiKey: API_KEY,
      dangerouslyAllowBrowser: true
    });
    
    // Step 1: List models to verify API key
    console.log('Listing models...');
    const models = await openai.models.list();
    console.log(`Successfully listed ${models.data.length} models`);
    
    // Step 2: Create a chat completion
    console.log('Creating chat completion...');
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo", // Use a cheaper model for testing
      messages: [
        { role: "system", content: `You are ${AGENT_NAME}. Answer questions concisely and accurately.` },
        { role: "user", content: "Hello, can you help me with something?" }
      ]
    });
    
    // Step 3: Display the result
    console.log('\nAgent response:');
    console.log(completion.choices[0].message.content);
    
    console.log('\nTest completed successfully!');
    return true;
  } catch (error) {
    console.error('Error testing OpenAI API:', error);
    return false;
  }
}

// Run the test
testOpenAI().then(success => {
  if (success) {
    console.log('API test passed! Your OpenAI API key is working correctly.');
  } else {
    console.log('API test failed. Please check your API key and ensure the OpenAI API is accessible.');
  }
});


================================================
FILE: src/components/AgentBuilder.js
================================================
import React, { useState, useEffect } from 'react';
import apiService from '../utils/apiService';
import { useNavigate, useParams } from 'react-router-dom';
import Box from '@mui/material/Box';
import Container from '@mui/material/Container';
import Paper from '@mui/material/Paper';
import Stepper from '@mui/material/Stepper';
import Step from '@mui/material/Step';
import StepLabel from '@mui/material/StepLabel';
import Button from '@mui/material/Button';
import Typography from '@mui/material/Typography';
import Divider from '@mui/material/Divider';
import Alert from '@mui/material/Alert';
import CircularProgress from '@mui/material/CircularProgress';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import SaveIcon from '@mui/icons-material/Save';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import CodeIcon from '@mui/icons-material/Code';

import BasicDetails from './builder/BasicDetails';
import InstructionsEditor from './builder/InstructionsEditor';
import ToolsSelector from './builder/ToolsSelector';
import HandoffsSelector from './builder/HandoffsSelector';
import GuardrailsConfigurator from './builder/GuardrailsConfigurator';
import CodePreview from './builder/CodePreview';
import TestAgent from './builder/TestAgent';

const steps = [
  'Basic Details',
  'Instructions',
  'Tools',
  'Handoffs',
  'Guardrails',
  'Code Preview',
  'Test Agent'
];

function AgentBuilder() {
  const navigate = useNavigate();
  const { agentId } = useParams();
  const [activeStep, setActiveStep] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [agentData, setAgentData] = useState({
    name: '',
    description: '',
    model: 'gpt-4o',
    instructions: 'You are a helpful assistant.',
    modelSettings: {
      temperature: 0.7,
      topP: 1,
      frequencyPenalty: 0,
      presencePenalty: 0
    },
    tools: [],
    handoffs: [],
    inputGuardrails: [],
    outputGuardrails: [],
    outputType: null
  });
  
  // Load agent data if editing an existing agent
  useEffect(() => {
    const loadAgentData = async () => {
      // Check if we have an agent ID from the URL
      if (agentId) {
        try {
          setLoading(true);
          
          // Get all agents and find the one with matching ID
          const agents = await apiService.getAgents();
          const foundAgent = agents.find(a => a.id === agentId);
          
          if (foundAgent) {
            setAgentData(foundAgent);
            setError(null);
          } else {
            setError(`Agent with ID ${agentId} not found`);
          }
        } catch (err) {
          console.error('Error loading agent:', err);
          setError('Failed to load agent: ' + (err.message || ''));
        } finally {
          setLoading(false);
        }
      } else {
        // Check if we have agent data in session storage (for cloning)
        const storedAgentData = sessionStorage.getItem('agent_to_edit');
        if (storedAgentData) {
          try {
            const parsedData = JSON.parse(storedAgentData);
            setAgentData(parsedData);
            // Clear the session storage after loading
            sessionStorage.removeItem('agent_to_edit');
          } catch (err) {
            console.error('Error parsing stored agent data:', err);
          }
        }
      }
    };
    
    loadAgentData();
  }, [agentId]);

  const handleNext = () => {
    setActiveStep((prev) => prev + 1);
  };

  const handleBack = () => {
    setActiveStep((prev) => prev - 1);
  };

  const updateAgentData = (field, value) => {
    setAgentData((prev) => ({
      ...prev,
      [field]: value
    }));
  };

  const handleSave = async () => {
    try {
      setLoading(true);
      
      // Save the agent using the API service
      let savedAgent;
      
      if (agentId) {
        // Update existing agent
        savedAgent = await apiService.updateAgent(agentId, agentData);
        console.log("Agent updated successfully:", savedAgent);
      } else {
        // Create new agent
        savedAgent = await apiService.createAgent(agentData);
        console.log("Agent created successfully:", savedAgent);
      }
      
      // Navigate back to dashboard
      navigate('/');
    } catch (error) {
      console.error("Error saving agent:", error);
      setError("Failed to save agent: " + (error.message || "Please try again."));
    } finally {
      setLoading(false);
    }
  };

  const getStepContent = (step) => {
    switch (step) {
      case 0:
        return (
          <BasicDetails 
            agentData={agentData} 
            updateAgentData={updateAgentData} 
          />
        );
      case 1:
        return (
          <InstructionsEditor 
            agentData={agentData} 
            updateAgentData={updateAgentData} 
          />
        );
      case 2:
        return (
          <ToolsSelector 
            agentData={agentData} 
            updateAgentData={updateAgentData} 
          />
        );
      case 3:
        return (
          <HandoffsSelector 
            agentData={agentData} 
            updateAgentData={updateAgentData} 
          />
        );
      case 4:
        return (
          <GuardrailsConfigurator 
            agentData={agentData} 
            updateAgentData={updateAgentData} 
          />
        );
      case 5:
        return (
          <CodePreview 
            agentData={agentData} 
          />
        );
      case 6:
        return (
          <TestAgent 
            agentData={agentData} 
          />
        );
      default:
        return 'Unknown step';
    }
  };

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 8 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 4 }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={() => navigate('/')}
          sx={{ mr: 2 }}
        >
          Back to Dashboard
        </Button>
        <Typography variant="h4" component="h1">
          {agentId ? 'Edit Agent' : 'Create Agent'}
        </Typography>
      </Box>
      
      {loading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', my: 8 }}>
          <CircularProgress />
        </Box>
      ) : error ? (
        <Alert severity="error" sx={{ mb: 4 }}>
          {error}
        </Alert>
      ) : (
        <Paper sx={{ p: 4, borderRadius: 2 }} elevation={2}>
          <Stepper activeStep={activeStep} alternativeLabel sx={{ mb: 4 }}>
            {steps.map((label) => (
              <Step key={label}>
                <StepLabel>{label}</StepLabel>
              </Step>
            ))}
          </Stepper>
          
          <Box>
            {getStepContent(activeStep)}
            
            <Divider sx={{ my: 4 }} />
            
            <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
              <Button
                variant="outlined"
                disabled={activeStep === 0}
                onClick={handleBack}
              >
                Back
              </Button>
              
              <Box>
                {activeStep === steps.length - 1 ? (
                  <>
                    <Button
                      variant="contained"
                      startIcon={<SaveIcon />}
                      onClick={handleSave}
                      disabled={loading}
                      sx={{ mr: 1 }}
                    >
                      {agentId ? 'Update Agent' : 'Save Agent'}
                    </Button>
                    <Button
                      variant="contained"
                      color="secondary"
                      startIcon={<PlayArrowIcon />}
                      onClick={() => {
                        handleSave().then(() => {
                          if (agentId) {
                            navigate(`/test/${agentId}`);
                          }
                        });
                      }}
                      disabled={loading}
                    >
                      Save & Run
                    </Button>
                  </>
                ) : (
                  <Button
                    variant="contained"
                    onClick={handleNext}
                    endIcon={activeStep === steps.length - 2 ? <CodeIcon /> : null}
                  >
                    {activeStep === steps.length - 2 ? 'Generate Code' : 'Next'}
                  </Button>
                )}
              </Box>
            </Box>
          </Box>
        </Paper>
      )}
    </Container>
  );
}

export default AgentBuilder;


================================================
FILE: src/components/AgentTester.js
================================================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import Box from '@mui/material/Box';
import Container from '@mui/material/Container';
import Paper from '@mui/material/Paper';
import Typography from '@mui/material/Typography';
import Button from '@mui/material/Button';
import CircularProgress from '@mui/material/CircularProgress';
import Alert from '@mui/material/Alert';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import apiService from '../utils/apiService';
import TestAgent from './builder/TestAgent';

function AgentTester() {
  const { agentId } = useParams();
  const navigate = useNavigate();
  const [agent, setAgent] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchAgent = async () => {
      try {
        setLoading(true);
        
        // Get all agents and find the one with matching ID
        const agents = await apiService.getAgents();
        const foundAgent = agents.find(a => a.id === agentId);
        
        if (foundAgent) {
          setAgent(foundAgent);
          setError(null);
        } else {
          setError(`Agent with ID ${agentId} not found`);
        }
      } catch (err) {
        console.error('Error fetching agent:', err);
        setError('Failed to load agent: ' + (err.message || ''));
      } finally {
        setLoading(false);
      }
    };

    if (agentId) {
      fetchAgent();
    } else {
      setError('No agent ID provided');
      setLoading(false);
    }
  }, [agentId]);

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 8 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 4 }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={() => navigate('/')}
          sx={{ mr: 2 }}
        >
          Back to Dashboard
        </Button>
        <Typography variant="h4" component="h1">
          Test Agent
        </Typography>
      </Box>

      {loading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', my: 8 }}>
          <CircularProgress />
        </Box>
      ) : error ? (
        <Alert severity="error" sx={{ mb: 4 }}>
          {error}
        </Alert>
      ) : agent ? (
        <Paper sx={{ p: 4, borderRadius: 2 }} elevation={2}>
          <Box sx={{ mb: 4 }}>
            <Typography variant="h5" gutterBottom>
              {agent.name}
            </Typography>
            <Typography variant="body1" color="text.secondary">
              {agent.description}
            </Typography>
          </Box>
          
          <TestAgent agentData={agent} />
        </Paper>
      ) : (
        <Alert severity="warning">
          Agent not found. Please select an agent from the dashboard.
        </Alert>
      )}
    </Container>
  );
}

export default AgentTester;


================================================
FILE: src/components/ApiKeySetup.js
================================================
import React, { useState } from 'react';
import apiService from '../utils/apiService';
import Box from '@mui/material/Box';
import Container from '@mui/material/Container';
import Paper from '@mui/material/Paper';
import Typography from '@mui/material/Typography';
import TextField from '@mui/material/TextField';
import Button from '@mui/material/Button';
import Alert from '@mui/material/Alert';
import AlertTitle from '@mui/material/AlertTitle';
import SmartToyOutlinedIcon from '@mui/icons-material/SmartToyOutlined';
import KeyIcon from '@mui/icons-material/Key';

function ApiKeySetup({ onApiKeySet }) {
  const [apiKey, setApiKey] = useState('');
  const [error, setError] = useState('');

  const [isValidating, setIsValidating] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!apiKey.trim() || !apiKey.startsWith('sk-')) {
      setError('Please enter a valid OpenAI API key starting with "sk-"');
      return;
    }
    
    try {
      setIsValidating(true);
      setError('');
      
      // Validate the API key with OpenAI
      await apiService.validateApiKey(apiKey);
      
      // If validation succeeds, save the key and continue
      localStorage.setItem('openai_api_key', apiKey);
      onApiKeySet();
    } catch (error) {
      setError(error.message || 'Failed to validate API key. Please check your key and try again.');
    } finally {
      setIsValidating(false);
    }
  };

  return (
    <Container maxWidth="sm" sx={{ mt: 8 }}>
      <Paper
        sx={{
          p: 4,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          borderRadius: 2,
        }}
        elevation={3}
      >
        <Box sx={{ 
          display: 'flex', 
          alignItems: 'center', 
          mb: 3,
          color: 'primary.main'
        }}>
          <SmartToyOutlinedIcon sx={{ fontSize: 40, mr: 1 }} />
          <Typography variant="h4" component="h1">
            Agent Builder
          </Typography>
        </Box>
        
        <Typography variant="h6" gutterBottom>
          Welcome to OpenAI Agent Builder
        </Typography>
        
        <Typography variant="body1" sx={{ mb: 4, textAlign: 'center' }}>
          To get started, please enter your OpenAI API key.
          This will be stored locally and used to interact with the OpenAI API.
        </Typography>
        
        {error && (
          <Alert severity="error" sx={{ width: '100%', mb: 3 }}>
            <AlertTitle>Error</AlertTitle>
            {error}
          </Alert>
        )}
        
        <Box component="form" onSubmit={handleSubmit} sx={{ width: '100%' }}>
          <TextField
            fullWidth
            label="OpenAI API Key"
            variant="outlined"
            value={apiKey}
            onChange={(e) => setApiKey(e.target.value)}
            placeholder="sk-..."
            InputProps={{
              startAdornment: <KeyIcon sx={{ mr: 1, color: 'text.secondary' }} />,
            }}
            sx={{ mb: 3 }}
          />
          
          <Button
            type="submit"
            fullWidth
            variant="contained"
            size="large"
            disabled={isValidating}
            sx={{ py: 1.5 }}
          >
            {isValidating ? 'Validating...' : 'Continue'}
          </Button>
        </Box>
      </Paper>
    </Container>
  );
}

export default ApiKeySetup;


================================================
FILE: src/components/Dashboard.js
================================================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import Box from '@mui/material/Box';
import Container from '@mui/material/Container';
import Grid from '@mui/material/Grid';
import Card from '@mui/material/Card';
import CardContent from '@mui/material/CardContent';
import CardActions from '@mui/material/CardActions';
import Typography from '@mui/material/Typography';
import Button from '@mui/material/Button';
import Chip from '@mui/material/Chip';
import IconButton from '@mui/material/IconButton';
import Divider from '@mui/material/Divider';
import Paper from '@mui/material/Paper';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';
// CircularProgress is not used in this file, so we're removing it
import AddIcon from '@mui/icons-material/Add';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import EditIcon from '@mui/icons-material/Edit';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import DeleteOutlineIcon from '@mui/icons-material/DeleteOutline';
import WarningIcon from '@mui/icons-material/Warning';

import apiService from '../utils/apiService';

function Dashboard() {
  const navigate = useNavigate();
  const [agents, setAgents] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // State for delete confirmation
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [agentToDelete, setAgentToDelete] = useState(null);
  
  // Fetch agents when component mounts
  useEffect(() => {
    fetchAgents();
  }, []);
  
  // Function to fetch agents
  const fetchAgents = async () => {
    try {
      setLoading(true);
      const agentData = await apiService.getAgents();
      setAgents(agentData);
      setError(null);
    } catch (err) {
      console.error('Error fetching agents:', err);
      setError('Failed to load agents. ' + (err.message || ''));
    } finally {
      setLoading(false);
    }
  };
  
  // Function to handle running an agent
  const handleRunAgent = (agentId) => {
    // Navigate to a test page for this agent
    navigate(`/test/${agentId}`);
  };
  
  // Function to handle editing an agent
  const handleEditAgent = (agentId) => {
    // Navigate to the builder with this agent loaded
    navigate(`/build/${agentId}`);
  };
  
  // Function to handle cloning an agent
  const handleCloneAgent = (agentId) => {
    const agentToClone = agents.find(agent => agent.id === agentId);
    if (agentToClone) {
      // Create a new agent based on the existing one
      const clonedAgent = {
        ...agentToClone,
        name: `${agentToClone.name} (Clone)`,
        id: undefined // Remove ID so a new one will be generated
      };
      
      // Store in session storage for the builder to pick up
      sessionStorage.setItem('agent_to_edit', JSON.stringify(clonedAgent));
      navigate('/build');
    }
  };
  
  // Function to handle deleting an agent
  const handleDeleteAgent = (agentId) => {
    setAgentToDelete(agentId);
    setDeleteDialogOpen(true);
  };
  
  // Function to confirm agent deletion
  const confirmDeleteAgent = async () => {
    if (!agentToDelete) return;
    
    try {
      setLoading(true);
      
      // Call the API to delete the agent
      await apiService.deleteAgent(agentToDelete);
      
      // Remove from local state
      setAgents(agents.filter(agent => agent.id !== agentToDelete));
      
      // Close dialog
      setDeleteDialogOpen(false);
      setAgentToDelete(null);
      setError(null);
    } catch (error) {
      console.error('Error deleting agent:', error);
      setError('Failed to delete agent: ' + (error.message || ''));
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 8 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
        <Typography variant="h4" component="h1">
          Your Agents
        </Typography>
        <Button 
          variant="contained" 
          startIcon={<AddIcon />}
          size="large"
          onClick={() => navigate('/build')}
        >
          Create Agent
        </Button>
      </Box>
      
      {loading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', my: 4 }}>
          <Typography>Loading agents...</Typography>
        </Box>
      ) : error ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', my: 4 }}>
          <Typography color="error">{error}</Typography>
        </Box>
      ) : (
        <Grid container spacing={3}>
          {agents.map((agent) => (
          <Grid item xs={12} md={4} key={agent.id}>
            <Card className="card" sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
              <CardContent sx={{ flexGrow: 1 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                  <Typography variant="h6" component="h2">
                    {agent.name}
                  </Typography>
                  <Chip 
                    label={agent.model} 
                    size="small" 
                    color="primary" 
                    variant="outlined" 
                  />
                </Box>
                
                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  {agent.description}
                </Typography>
                
                <Typography variant="caption" color="text.secondary">
                  Tools:
                </Typography>
                <Box sx={{ mt: 1 }}>
                  {agent.tools.map((tool, index) => (
                    <Chip
                      key={index}
                      label={tool.name || tool}
                      size="small"
                      sx={{ mr: 0.5, mb: 0.5 }}
                    />
                  ))}
                </Box>
              </CardContent>
              
              <Divider />
              
              <CardActions sx={{ justifyContent: 'space-between', p: 1 }}>
                <Button
                  size="small"
                  startIcon={<PlayArrowIcon />}
                  color="primary"
                  onClick={() => handleRunAgent(agent.id)}
                >
                  Run
                </Button>
                
                <Box>
                  <IconButton
                    size="small"
                    color="primary"
                    title="Edit"
                    onClick={() => handleEditAgent(agent.id)}
                  >
                    <EditIcon fontSize="small" />
                  </IconButton>
                  <IconButton
                    size="small"
                    color="primary"
                    title="Clone"
                    onClick={() => handleCloneAgent(agent.id)}
                  >
                    <ContentCopyIcon fontSize="small" />
                  </IconButton>
                  <IconButton
                    size="small"
                    color="error"
                    title="Delete"
                    onClick={() => handleDeleteAgent(agent.id)}
                  >
                    <DeleteOutlineIcon fontSize="small" />
                  </IconButton>
                </Box>
              </CardActions>
              
              <Box sx={{ px: 2, py: 1, bgcolor: 'grey.50' }}>
                <Typography variant="caption" color="text.secondary">
                  Last used: {agent.lastUsed}
                </Typography>
              </Box>
            </Card>
          </Grid>
        ))}
        
        <Grid item xs={12} md={4}>
          <Paper
            sx={{
              height: '100%',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              p: 4,
              borderRadius: 2,
              border: '2px dashed',
              borderColor: 'grey.300',
              bgcolor: 'background.paper',
            }}
            elevation={0}
          >
            <IconButton
              color="primary"
              sx={{ mb: 2, p: 2, bgcolor: 'primary.light', color: 'white' }}
              onClick={() => navigate('/build')}
            >
              <AddIcon fontSize="large" />
            </IconButton>
            <Typography variant="h6" component="div" align="center">
              Create New Agent
            </Typography>
            <Typography variant="body2" color="text.secondary" align="center">
              Build a custom agent with specialized tools
            </Typography>
          </Paper>
        </Grid>
        </Grid>
      )}
      
      {/* Delete Confirmation Dialog */}
      <Dialog
        open={deleteDialogOpen}
        onClose={() => setDeleteDialogOpen(false)}
      >
        <DialogTitle sx={{ display: 'flex', alignItems: 'center' }}>
          <WarningIcon color="warning" sx={{ mr: 1 }} />
          Confirm Delete
        </DialogTitle>
        <DialogContent>
          <DialogContentText>
            Are you sure you want to delete this agent? This action cannot be undone.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteDialogOpen(false)}>
            Cancel
          </Button>
          <Button
            onClick={confirmDeleteAgent}
            color="error"
            variant="contained"
          >
            Delete
          </Button>
        </DialogActions>
      </Dialog>
    </Container>
  );
}

export default Dashboard;


================================================
FILE: src/components/Navbar.js
================================================
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import AppBar from '@mui/material/AppBar';
import Box from '@mui/material/Box';
import Toolbar from '@mui/material/Toolbar';
import Typography from '@mui/material/Typography';
import Button from '@mui/material/Button';
import IconButton from '@mui/material/IconButton';
import SmartToyOutlinedIcon from '@mui/icons-material/SmartToyOutlined';
import DarkModeOutlinedIcon from '@mui/icons-material/DarkModeOutlined';
import LightModeOutlinedIcon from '@mui/icons-material/LightModeOutlined';
import Tooltip from '@mui/material/Tooltip';

function Navbar({ darkMode, toggleDarkMode }) {
  return (
    <Box sx={{ flexGrow: 1 }}>
      <AppBar position="static" color="default" elevation={1}>
        <Toolbar>
          <IconButton
            size="large"
            edge="start"
            color="primary"
            aria-label="logo"
            sx={{ mr: 2 }}
            component={RouterLink}
            to="/"
          >
            <SmartToyOutlinedIcon />
          </IconButton>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            OpenAI Agent Builder
          </Typography>
          
          <Button 
            color="inherit" 
            component={RouterLink} 
            to="/"
            sx={{ mx: 1 }}
          >
            Dashboard
          </Button>
          
          <Button 
            color="primary"
            variant="contained"
            component={RouterLink}
            to="/build"
            sx={{ mx: 1 }}
          >
            Create Agent
          </Button>
          
          <Tooltip title="Toggle Dark Mode">
            <IconButton 
              color="inherit" 
              sx={{ ml: 1 }}
              onClick={toggleDarkMode}
              aria-label="toggle dark mode"
            >
              {darkMode ? <LightModeOutlinedIcon /> : <DarkModeOutlinedIcon />}
            </IconButton>
          </Tooltip>
        </Toolbar>
      </AppBar>
    </Box>
  );
}

export default Navbar;


================================================
FILE: src/components/builder/BasicDetails.js
================================================
import React from 'react';
import Box from '@mui/material/Box';
import Grid from '@mui/material/Grid';
import TextField from '@mui/material/TextField';
import Typography from '@mui/material/Typography';
import FormControl from '@mui/material/FormControl';
import InputLabel from '@mui/material/InputLabel';
import Select from '@mui/material/Select';
import MenuItem from '@mui/material/MenuItem';
import Slider from '@mui/material/Slider';
import InputAdornment from '@mui/material/InputAdornment';
import Tooltip from '@mui/material/Tooltip';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';
import { modelOptions } from '../../utils/modelOptions';

function BasicDetails({ agentData, updateAgentData }) {
  const handleModelSettingChange = (setting, value) => {
    updateAgentData('modelSettings', {
      ...agentData.modelSettings,
      [setting]: value
    });
  };

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Agent Details
      </Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
        Configure the basic details and model settings for your agent.
      </Typography>
      
      <Grid container spacing={3}>
        <Grid item xs={12} md={6}>
          <TextField
            fullWidth
            label="Agent Name"
            value={agentData.name}
            onChange={(e) => updateAgentData('name', e.target.value)}
            placeholder="e.g., Customer Support Agent"
            helperText="A descriptive name for your agent"
            required
          />
        </Grid>
        
        <Grid item xs={12} md={6}>
          <FormControl fullWidth>
            <InputLabel>Model</InputLabel>
            <Select
              value={agentData.model}
              onChange={(e) => updateAgentData('model', e.target.value)}
              label="Model"
            >
              {modelOptions.map((option) => (
                <MenuItem key={option.value} value={option.value}>
                  <Box>
                    <Typography variant="body1">{option.label}</Typography>
                    <Typography variant="caption" color="text.secondary">
                      {option.description}
                    </Typography>
                  </Box>
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Grid>
        
        <Grid item xs={12}>
          <TextField
            fullWidth
            label="Agent Description"
            value={agentData.description}
            onChange={(e) => updateAgentData('description', e.target.value)}
            placeholder="e.g., Handles customer inquiries and routes to specialists when needed"
            helperText="A brief description of what this agent does"
            multiline
            rows={2}
          />
        </Grid>
        
        <Grid item xs={12}>
          <Typography variant="subtitle1" gutterBottom sx={{ mt: 2 }}>
            Model Settings
          </Typography>
        </Grid>
        
        <Grid item xs={12} md={6}>
          <Box sx={{ px: 2 }}>
            <Typography variant="body2" gutterBottom>
              Temperature
              <Tooltip title="Controls randomness. Lower values make responses more focused and deterministic, higher values make responses more creative and varied.">
                <InfoOutlinedIcon fontSize="small" sx={{ ml: 1, verticalAlign: 'middle', color: 'text.secondary' }} />
              </Tooltip>
            </Typography>
            <Slider
              value={agentData.modelSettings.temperature}
              onChange={(_, value) => handleModelSettingChange('temperature', value)}
              min={0}
              max={1}
              step={0.1}
              marks={[
                { value: 0, label: '0' },
                { value: 0.5, label: '0.5' },
                { value: 1, label: '1' },
              ]}
              valueLabelDisplay="auto"
            />
          </Box>
        </Grid>
        
        <Grid item xs={12} md={6}>
          <Box sx={{ px: 2 }}>
            <Typography variant="body2" gutterBottom>
              Top P
              <Tooltip title="Controls diversity. Lower values make the model focus on higher probability tokens, higher values allow more diverse options.">
                <InfoOutlinedIcon fontSize="small" sx={{ ml: 1, verticalAlign: 'middle', color: 'text.secondary' }} />
              </Tooltip>
            </Typography>
            <Slider
              value={agentData.modelSettings.topP}
              onChange={(_, value) => handleModelSettingChange('topP', value)}
              min={0}
              max={1}
              step={0.1}
              marks={[
                { value: 0, label: '0' },
                { value: 0.5, label: '0.5' },
                { value: 1, label: '1' },
              ]}
              valueLabelDisplay="auto"
            />
          </Box>
        </Grid>
        
        <Grid item xs={12} md={6}>
          <TextField
            fullWidth
            label="Frequency Penalty"
            type="number"
            value={agentData.modelSettings.frequencyPenalty}
            onChange={(e) => handleModelSettingChange('frequencyPenalty', parseFloat(e.target.value))}
            InputProps={{
              inputProps: { min: -2, max: 2, step: 0.1 },
              startAdornment: (
                <InputAdornment position="start">
                  <Tooltip title="Penalizes repetition. Positive values decrease the likelihood of repeating the same words.">
                    <InfoOutlinedIcon fontSize="small" sx={{ color: 'text.secondary' }} />
                  </Tooltip>
                </InputAdornment>
              ),
            }}
          />
        </Grid>
        
        <Grid item xs={12} md={6}>
          <TextField
            fullWidth
            label="Presence Penalty"
            type="number"
            value={agentData.modelSettings.presencePenalty}
            onChange={(e) => handleModelSettingChange('presencePenalty', parseFloat(e.target.value))}
            InputProps={{
              inputProps: { min: -2, max: 2, step: 0.1 },
              startAdornment: (
                <InputAdornment position="start">
                  <Tooltip title="Encourages talking about new topics. Positive values increase the likelihood of introducing new concepts.">
                    <InfoOutlinedIcon fontSize="small" sx={{ color: 'text.secondary' }} />
                  </Tooltip>
                </InputAdornment>
              ),
            }}
          />
        </Grid>
      </Grid>
    </Box>
  );
}

export default BasicDetails;


================================================
FILE: src/components/builder/CodePreview.js
================================================
import React, { useState, useEffect } from 'react';
import Box from '@mui/material/Box';
import Paper from '@mui/material/Paper';
import Typography from '@mui/material/Typography';
import Stack from '@mui/material/Stack';
import Button from '@mui/material/Button';
import Chip from '@mui/material/Chip';
import Divider from '@mui/material/Divider';
import Tabs from '@mui/material/Tabs';
import Tab from '@mui/material/Tab';
import Alert from '@mui/material/Alert';
import Editor from '@monaco-editor/react';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import FileDownloadIcon from '@mui/icons-material/FileDownload';
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import CodeIcon from '@mui/icons-material/Code';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';

import { 
  agentTemplate, 
  runnerTemplate, 
  streamingTemplate 
} from '../../utils/codeTemplates';

function CodePreview({ agentData }) {
  const [tabValue, setTabValue] = useState(0);
  const [copied, setCopied] = useState(false);
  const [agentCode, setAgentCode] = useState('');
  const [runnerCode, setRunnerCode] = useState('');
  const [streamingCode, setStreamingCode] = useState('');

  // Define tab change handler
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  // Define memoized functions first to avoid initialization issues
  const generateAgentCode = React.useCallback(() => {
    let code = agentTemplate
      .replace('{{name}}', agentData.name || 'MyAgent')
      .replace('{{instructions}}', agentData.instructions || 'Your instructions here')
      .replace('{{model}}', agentData.model || 'gpt-4o');

    // Format tools
    let toolsStr = '';
    if (agentData.tools && agentData.tools.length > 0) {
      toolsStr = agentData.tools.map(tool => tool.name).join(', ');
    }
    code = code.replace('{{tools}}', toolsStr);

    // Format handoffs
    let handoffsStr = '';
    if (agentData.handoffs && agentData.handoffs.length > 0) {
      handoffsStr = agentData.handoffs.map(handoff => 
        handoff.specialistName || handoff.name
      ).join(', ');
    }
    code = code.replace('{{handoffs}}', handoffsStr);

    setAgentCode(code);
  }, [agentData]);

  const generateRunnerCode = React.useCallback(() => {
    const code = runnerTemplate.replace('{{prompt}}', 'Hello, how can you help me?');
    setRunnerCode(code);
  }, []);

  const generateStreamingCode = React.useCallback(() => {
    const code = streamingTemplate.replace('{{prompt}}', 'Hello, how can you help me?');
    setStreamingCode(code);
  }, []);

  // Use effect to generate code when component mounts or agentData changes
  useEffect(() => {
    // Generate agent code based on user selections
    generateAgentCode();
    generateRunnerCode();
    generateStreamingCode();
  }, [agentData, generateAgentCode, generateRunnerCode, generateStreamingCode]);

  const handleCopyCode = () => {
    let codeToCopy;
    
    switch (tabValue) {
      case 0:
        codeToCopy = agentCode;
        break;
      case 1:
        codeToCopy = runnerCode;
        break;
      case 2:
        codeToCopy = streamingCode;
        break;
      default:
        codeToCopy = agentCode;
    }
    
    navigator.clipboard.writeText(codeToCopy);
    setCopied(true);
    
    setTimeout(() => {
      setCopied(false);
    }, 2000);
  };

  const handleDownloadCode = () => {
    let codeToCopy;
    let filename;
    
    switch (tabValue) {
      case 0:
        codeToCopy = agentCode;
        filename = 'agent.py';
        break;
      case 1:
        codeToCopy = runnerCode;
        filename = 'runner.py';
        break;
      case 2:
        codeToCopy = streamingCode;
        filename = 'streaming.py';
        break;
      default:
        codeToCopy = agentCode;
        filename = 'agent.py';
    }
    
    const element = document.createElement('a');
    const file = new Blob([codeToCopy], {type: 'text/plain'});
    element.href = URL.createObjectURL(file);
    element.download = filename;
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  };

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Generated Code
      </Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
        Review the generated Python code for your agent. You can copy or download this code to use in your application.
      </Typography>
      
      <Alert severity="info" sx={{ mb: 3 }}>
        This code is ready to use with the OpenAI Agents SDK. Make sure you have installed the SDK and configured your API key.
      </Alert>
      
      <Paper sx={{ mb: 3 }} elevation={3}>
        <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
          <Tabs value={tabValue} onChange={handleTabChange}>
            <Tab label="Agent Definition" icon={<CodeIcon />} iconPosition="start" />
            <Tab label="Runner" icon={<PlayArrowIcon />} iconPosition="start" />
            <Tab label="Streaming" icon={<PlayArrowIcon />} iconPosition="start" />
          </Tabs>
        </Box>
        
        <Box sx={{ p: 0 }}>
          {tabValue === 0 && (
            <Editor
              height="400px"
              language="python"
              theme="light"
              value={agentCode}
              options={{
                readOnly: true,
                minimap: { enabled: false },
                scrollBeyondLastLine: false,
              }}
            />
          )}
          {tabValue === 1 && (
            <Editor
              height="400px"
              language="python"
              theme="light"
              value={runnerCode}
              options={{
                readOnly: true,
                minimap: { enabled: false },
                scrollBeyondLastLine: false,
              }}
            />
          )}
          {tabValue === 2 && (
            <Editor
              height="400px"
              language="python"
              theme="light"
              value={streamingCode}
              options={{
                readOnly: true,
                minimap: { enabled: false },
                scrollBeyondLastLine: false,
              }}
            />
          )}
        </Box>
        
        <Divider />
        
        <Box sx={{ p: 2, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Stack direction="row" spacing={1}>
            <Chip label="Python" color="primary" variant="outlined" size="small" />
            <Chip label="OpenAI Agents SDK" variant="outlined" size="small" />
          </Stack>
          
          <Box>
            <Button
              startIcon={copied ? <CheckCircleOutlineIcon /> : <ContentCopyIcon />}
              onClick={handleCopyCode}
              color={copied ? "success" : "primary"}
              sx={{ mr: 1 }}
            >
              {copied ? "Copied!" : "Copy Code"}
            </Button>
            
            <Button
              startIcon={<FileDownloadIcon />}
              variant="outlined"
              onClick={handleDownloadCode}
            >
              Download
            </Button>
          </Box>
        </Box>
      </Paper>
      
      <Typography variant="subtitle1" gutterBottom>
        Next Steps
      </Typography>
      <Typography variant="body2" paragraph>
        Test your agent in the next step to make sure it behaves as expected. You can also use this code directly in your application.
      </Typography>
    </Box>
  );
}

export default CodePreview;


================================================
FILE: src/components/builder/GuardrailsConfigurator.js
================================================
import React, { useState } from 'react';
import Box from '@mui/material/Box';
import Grid from '@mui/material/Grid';
import Paper from '@mui/material/Paper';
import Typography from '@mui/material/Typography';
import FormGroup from '@mui/material/FormGroup';
import FormControlLabel from '@mui/material/FormControlLabel';
import Switch from '@mui/material/Switch';
// import TextField from '@mui/material/TextField'; // Commented out but kept for future use
import Button from '@mui/material/Button';
import Chip from '@mui/material/Chip';
import Alert from '@mui/material/Alert';
import Tabs from '@mui/material/Tabs';
import Tab from '@mui/material/Tab';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import Stack from '@mui/material/Stack';
import AddIcon from '@mui/icons-material/Add';
import ShieldIcon from '@mui/icons-material/Shield';
import CodeIcon from '@mui/icons-material/Code';
import SecurityIcon from '@mui/icons-material/Security';
import SecurityOutlinedIcon from '@mui/icons-material/SecurityOutlined';
import Editor from '@monaco-editor/react';
import { guardrailTemplate } from '../../utils/codeTemplates';

function TabPanel(props) {
  const { children, value, index, ...other } = props;
  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`simple-tabpanel-${index}`}
      aria-labelledby={`simple-tab-${index}`}
      {...other}
    >
      {value === index && (
        <Box sx={{ p: 2 }}>
          {children}
        </Box>
      )}
    </div>
  );
}

function GuardrailsConfigurator({ agentData, updateAgentData }) {
  const [tabValue, setTabValue] = useState(0);
  const [openDialog, setOpenDialog] = useState(false);
  const [guardType, setGuardType] = useState('input');
  const [guardrailCode, setGuardrailCode] = useState('');
  const [enabledGuardrails, setEnabledGuardrails] = useState({
    contentFilter: true,
    piiDetection: false,
    toxicityCheck: false,
    jailbreakDetection: true
  });

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  const handleOpenCodeDialog = (type) => {
    setGuardType(type);
    
    // Set a template code for the guardrail
    const template = guardrailTemplate.replace(
      '{{name}}', 
      agentData.name || 'MyAgent'
    ).replace(
      '{{instructions}}', 
      agentData.instructions ? agentData.instructions.substring(0, 40) + '...' : 'Your instructions here'
    );
    
    setGuardrailCode(template);
    setOpenDialog(true);
  };

  const handleCloseDialog = () => {
    setOpenDialog(false);
  };

  const handleSaveGuardrail = () => {
    // In a real app, we would validate and save the guardrail code
    // For now, we'll just close the dialog
    setOpenDialog(false);
  };

  const handleGuardrailToggle = (name) => (event) => {
    setEnabledGuardrails({
      ...enabledGuardrails,
      [name]: event.target.checked
    });
  };

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Guardrails Configuration
      </Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
        Configure guardrails to ensure your agent operates safely and appropriately. Guardrails can validate both user inputs and agent outputs.
      </Typography>
      
      <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}>
        <Tabs value={tabValue} onChange={handleTabChange}>
          <Tab label="Input Guardrails" icon={<SecurityIcon />} iconPosition="start" />
          <Tab label="Output Guardrails" icon={<SecurityOutlinedIcon />} iconPosition="start" />
          <Tab label="Structured Output" icon={<CodeIcon />} iconPosition="start" />
        </Tabs>
      </Box>
      
      <TabPanel value={tabValue} index={0}>
        <Alert severity="info" sx={{ mb: 3 }}>
          Input guardrails validate user inputs before they reach your agent, preventing inappropriate requests or content.
        </Alert>
        
        <Grid container spacing={3}>
          <Grid item xs={12} md={6}>
            <Paper sx={{ p: 2 }}>
              <Typography variant="subtitle1" gutterBottom>
                Predefined Guardrails
              </Typography>
              <FormGroup>
                <FormControlLabel 
                  control={
                    <Switch 
                      checked={enabledGuardrails.contentFilter} 
                      onChange={handleGuardrailToggle('contentFilter')}
                    />
                  } 
                  label="Content Filter"
                />
                <Typography variant="caption" color="text.secondary" sx={{ pl: 4, mt: -1, mb: 1 }}>
                  Block harmful, illegal, unethical, or deceptive content
                </Typography>
                
                <FormControlLabel 
                  control={
                    <Switch 
                      checked={enabledGuardrails.jailbreakDetection} 
                      onChange={handleGuardrailToggle('jailbreakDetection')}
                    />
                  } 
                  label="Jailbreak Detection"
                />
                <Typography variant="caption" color="text.secondary" sx={{ pl: 4, mt: -1, mb: 1 }}>
                  Detect and block attempts to bypass agent instructions or limitations
                </Typography>
                
                <FormControlLabel 
                  control={
                    <Switch 
                      checked={enabledGuardrails.piiDetection} 
                      onChange={handleGuardrailToggle('piiDetection')}
                    />
                  } 
                  label="PII Detection"
                />
                <Typography variant="caption" color="text.secondary" sx={{ pl: 4, mt: -1, mb: 1 }}>
                  Identify and handle personally identifiable information in user inputs
                </Typography>
              </FormGroup>
            </Paper>
          </Grid>
          
          <Grid item xs={12} md={6}>
            <Paper sx={{ p: 2, height: '100%', display: 'flex', flexDirection: 'column' }}>
              <Typography variant="subtitle1" gutterBottom>
                Custom Input Guardrails
              </Typography>
              
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                Create custom input validation logic with Python code.
              </Typography>
              
              <Box sx={{ flexGrow: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                <Button
                  variant="outlined"
                  startIcon={<AddIcon />}
                  onClick={() => handleOpenCodeDialog('input')}
                >
                  Add Custom Input Guardrail
                </Button>
              </Box>
            </Paper>
          </Grid>
        </Grid>
      </TabPanel>
      
      <TabPanel value={tabValue} index={1}>
        <Alert severity="info" sx={{ mb: 3 }}>
          Output guardrails validate your agent's responses before they reach the user, ensuring content adheres to guidelines.
        </Alert>
        
        <Grid container spacing={3}>
          <Grid item xs={12} md={6}>
            <Paper sx={{ p: 2 }}>
              <Typography variant="subtitle1" gutterBottom>
                Predefined Output Filters
              </Typography>
              <FormGroup>
                <FormControlLabel 
                  control={
                    <Switch 
                      checked={enabledGuardrails.toxicityCheck} 
                      onChange={handleGuardrailToggle('toxicityCheck')}
                    />
                  } 
                  label="Toxicity Check"
                />
                <Typography variant="caption" color="text.secondary" sx={{ pl: 4, mt: -1, mb: 1 }}>
                  Filter out toxic, offensive, or inappropriate responses
                </Typography>
              </FormGroup>
            </Paper>
          </Grid>
          
          <Grid item xs={12} md={6}>
            <Paper sx={{ p: 2, height: '100%', display: 'flex', flexDirection: 'column' }}>
              <Typography variant="subtitle1" gutterBottom>
                Custom Output Guardrails
              </Typography>
              
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                Create custom validation for agent responses.
              </Typography>
              
              <Box sx={{ flexGrow: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                <Button
                  variant="outlined"
                  startIcon={<AddIcon />}
                  onClick={() => handleOpenCodeDialog('output')}
                >
                  Add Custom Output Guardrail
                </Button>
              </Box>
            </Paper>
          </Grid>
        </Grid>
      </TabPanel>
      
      <TabPanel value={tabValue} index={2}>
        <Alert severity="info" sx={{ mb: 3 }}>
          Define structured output types to ensure your agent returns consistently formatted data.
        </Alert>
        
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <Paper sx={{ p: 3 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                <ShieldIcon color="primary" sx={{ mr: 1 }} />
                <Typography variant="h6">
                  Structured Output Definition
                </Typography>
              </Box>
              
              <Typography variant="body2" sx={{ mb: 3 }}>
                Define a Pydantic model to enforce a specific structure for your agent's responses.
              </Typography>
              
              <Box sx={{ border: 1, borderColor: 'divider', borderRadius: 1, mb: 3 }}>
                <Editor
                  height="300px"
                  language="python"
                  theme="light"
                  value={`from pydantic import BaseModel

class AgentResponse(BaseModel):
    response: str
    confidence: float = 0.0
    sources: list[str] = []

# Use with:
# agent = Agent(
#     name="Structured Agent",
#     instructions="Provide responses with confidence scores",
#     output_type=AgentResponse,
# )`}
                  options={{
                    readOnly: true,
                    minimap: { enabled: false },
                    scrollBeyondLastLine: false,
                  }}
                />
              </Box>
              
              <Button
                variant="contained"
                color="primary"
                startIcon={<CodeIcon />}
              >
                Configure Structured Output
              </Button>
            </Paper>
          </Grid>
        </Grid>
      </TabPanel>
      
      <Dialog
        open={openDialog}
        onClose={handleCloseDialog}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {guardType === 'input' ? 'Custom Input Guardrail' : 'Custom Output Guardrail'}
        </DialogTitle>
        <DialogContent dividers>
          <Typography variant="body2" paragraph>
            Define a custom guardrail function using Python code. Your function should:
          </Typography>
          <Stack direction="row" spacing={1} sx={{ mb: 2 }}>
            <Chip label="Return GuardrailFunctionOutput" />
            <Chip label="Set tripwire_triggered to a boolean" />
            <Chip label="Include output_info with relevant details" />
          </Stack>
          
          <Box sx={{ height: 400 }}>
            <Editor
              height="100%"
              language="python"
              theme="light"
              value={guardrailCode}
              onChange={setGuardrailCode}
              options={{
                minimap: { enabled: false },
                scrollBeyondLastLine: false,
              }}
            />
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>
            Cancel
          </Button>
          <Button 
            onClick={handleSaveGuardrail} 
            variant="contained"
          >
            Save Guardrail
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
}

export default GuardrailsConfigurator;


================================================
FILE: src/components/builder/HandoffsSelector.js
================================================
import React, { useState } from 'react';
import Box from '@mui/material/Box';
import Grid from '@mui/material/Grid';
import Paper from '@mui/material/Paper';
import Typography from '@mui/material/Typography';
import List from '@mui/material/List';
import ListItem from '@mui/material/ListItem';
import ListItemText from '@mui/material/ListItemText';
import ListItemIcon from '@mui/material/ListItemIcon';
// import ListItemButton from '@mui/material/ListItemButton'; // Not used but kept for future
import Divider from '@mui/material/Divider';
import Chip from '@mui/material/Chip';
import Button from '@mui/material/Button';
import TextField from '@mui/material/TextField';
import Alert from '@mui/material/Alert';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import IconButton from '@mui/material/IconButton';
// import FormControl from '@mui/material/FormControl'; // Not used but kept for future
// import InputLabel from '@mui/material/InputLabel'; // Not used but kept for future
// import Select from '@mui/material/Select'; // Not used but kept for future
// import MenuItem from '@mui/material/MenuItem'; // Not used but kept for future
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material/Add';
// import EditIcon from '@mui/icons-material/Edit'; // Not used but kept for future
import ArrowForwardIcon from '@mui/icons-material/ArrowForward';
import PersonIcon from '@mui/icons-material/Person';
// import PersonOutlineIcon from '@mui/icons-material/PersonOutline'; // Not used but kept for future
// import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined'; // Not used but kept for future

// Sample specialist agents that could be used for handoffs
const sampleSpecialists = [
  {
    id: 'billing',
    name: 'Billing Agent',
    description: 'Handles billing inquiries and payment issues',
    model: 'o3-mini',
    category: 'Support'
  },
  {
    id: 'tech-support',
    name: 'Technical Support',
    description: 'Resolves technical issues and troubleshoots problems',
    model: 'gpt-4o',
    category: 'Support'
  },
  {
    id: 'refunds',
    name: 'Refund Specialist',
    description: 'Processes refund requests and handles related inquiries',
    model: 'o3-mini',
    category: 'Support'
  },
  {
    id: 'spanish',
    name: 'Spanish Translator',
    description: 'Translates content to Spanish',
    model: 'o3-mini',
    category: 'Language'
  },
  {
    id: 'french',
    name: 'French Translator',
    description: 'Translates content to French',
    model: 'o3-mini',
    category: 'Language'
  }
];

function HandoffsSelector({ agentData, updateAgentData }) {
  const [searchTerm, setSearchTerm] = useState('');
  // const [selectedSpecialist, setSelectedSpecialist] = useState(null); // Commented out for now, but kept for future use
  const [openDialog, setOpenDialog] = useState(false);
  const [newHandoff, setNewHandoff] = useState({
    id: '',
    name: '',
    toolName: '',
    description: ''
  });

  const handleAddHandoff = (specialist) => {
    // Format the handoff based on the selected specialist
    const handoff = {
      id: specialist.id,
      specialistId: specialist.id,
      specialistName: specialist.name,
      toolName: `escalate_to_${specialist.id.replace(/\s+/g, '_').toLowerCase()}`,
      description: `Escalate to ${specialist.name} for specialized assistance`
    };
    
    const updatedHandoffs = [...agentData.handoffs, handoff];
    updateAgentData('handoffs', updatedHandoffs);
  };

  const handleRemoveHandoff = (handoffId) => {
    const updatedHandoffs = agentData.handoffs.filter(handoff => handoff.id !== handoffId);
    updateAgentData('handoffs', updatedHandoffs);
  };

  const handleOpenNewHandoffDialog = () => {
    setNewHandoff({
      id: `handoff-${Date.now()}`,
      name: '',
      toolName: '',
      description: ''
    });
    setOpenDialog(true);
  };

  const handleCloseDialog = () => {
    setOpenDialog(false);
    // setSelectedSpecialist(null); // Commented out since variable is not currently used
  };

  const handleSaveHandoff = () => {
    if (newHandoff.name && newHandoff.toolName) {
      const handoff = {
        ...newHandoff,
        toolName: newHandoff.toolName.replace(/\s+/g, '_').toLowerCase()
      };
      
      const updatedHandoffs = [...agentData.handoffs, handoff];
      updateAgentData('handoffs', updatedHandoffs);
      setOpenDialog(false);
    }
  };

  const filteredSpecialists = sampleSpecialists.filter(
    specialist => specialist.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                  specialist.description.toLowerCase().includes(searchTerm.toLowerCase())
  );

  // Group specialists by category
  const groupedSpecialists = filteredSpecialists.reduce((acc, specialist) => {
    if (!acc[specialist.category]) {
      acc[specialist.category] = [];
    }
    acc[specialist.category].push(specialist);
    return acc;
  }, {});

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Agent Handoffs
      </Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
        Configure handoffs to specialist agents for specific tasks. Handoffs allow your main agent to delegate complex inquiries to specialized agents.
      </Typography>
      
      <Grid container spacing={3}>
        <Grid item xs={12} md={7}>
          <Paper sx={{ height: '100%', p: 2 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
              <TextField
                size="small"
                placeholder="Search specialists..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                sx={{ flexGrow: 1, mr: 2 }}
              />
              <Button
                variant="contained"
                startIcon={<AddIcon />}
                onClick={handleOpenNewHandoffDialog}
                size="small"
              >
                Custom Handoff
              </Button>
            </Box>
            
            {Object.entries(groupedSpecialists).map(([category, specialists]) => (
              <Box key={category} sx={{ mb: 3 }}>
                <Typography variant="subtitle2" sx={{ mb: 1, color: 'text.secondary' }}>
                  {category} Specialists
                </Typography>
                <List sx={{ bgcolor: 'background.paper', borderRadius: 1 }}>
                  {specialists.map((specialist) => {
                    const isAdded = agentData.handoffs.some(h => h.specialistId === specialist.id);
                    
                    return (
                      <ListItem 
                        key={specialist.id}
                        className="tool-item"
                        secondaryAction={
                          isAdded ? (
                            <IconButton 
                              edge="end" 
                              aria-label="remove" 
                              color="error"
                              onClick={() => handleRemoveHandoff(specialist.id)}
                            >
                              <DeleteIcon />
                            </IconButton>
                          ) : (
                            <Button
                              variant="outlined"
                              size="small"
                              onClick={() => handleAddHandoff(specialist)}
                            >
                              Add
                            </Button>
                          )
                        }
                      >
                        <ListItemIcon>
                          <PersonIcon />
                        </ListItemIcon>
                        <ListItemText
                          primary={
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                              {specialist.name}
                              {isAdded && (
                                <Chip 
                                  label="Added" 
                                  color="primary" 
                                  size="small" 
                                  sx={{ ml: 1 }}
                                />
                              )}
                            </Box>
                          }
                          secondary={
                            <>
                              {specialist.description}
                              <Chip 
                                label={specialist.model} 
                                size="small" 
                                variant="outlined"
                                sx={{ ml: 1 }}
                              />
                            </>
                          }
                        />
                      </ListItem>
                    );
                  })}
                </List>
              </Box>
            ))}
            
            {Object.keys(groupedSpecialists).length === 0 && (
              <Box sx={{ p: 3, textAlign: 'center' }}>
                <Typography variant="body2" color="text.secondary">
                  No specialists found matching your search.
                </Typography>
              </Box>
            )}
          </Paper>
        </Grid>
        
        <Grid item xs={12} md={5}>
          <Paper sx={{ p: 2, height: '100%' }}>
            <Typography variant="h6" gutterBottom>
              Active Handoffs
            </Typography>
            
            {agentData.handoffs.length === 0 ? (
              <Box 
                sx={{ 
                  p: 3, 
                  textAlign: 'center', 
                  border: '1px dashed', 
                  borderColor: 'grey.300',
                  borderRadius: 1
                }}
              >
                <Typography variant="body2" color="text.secondary">
                  No handoffs configured yet. Add specialists from the left panel to enable your agent to delegate tasks.
                </Typography>
              </Box>
            ) : (
              <>
                <Alert severity="info" sx={{ mb: 2 }}>
                  <Typography variant="body2">
                    Your agent will automatically determine when to use these handoffs.
                  </Typography>
                </Alert>
                
                <List>
                  {agentData.handoffs.map((handoff, index) => (
                    <React.Fragment key={handoff.id}>
                      {index > 0 && <Divider />}
                      <ListItem
                        secondaryAction={
                          <IconButton 
                            edge="end" 
                            aria-label="remove" 
                            color="error"
                            onClick={() => handleRemoveHandoff(handoff.id)}
                          >
                            <DeleteIcon />
                          </IconButton>
                        }
                      >
                        <ListItemIcon>
                          <ArrowForwardIcon color="primary" />
                        </ListItemIcon>
                        <ListItemText
                          primary={handoff.specialistName || handoff.name}
                          secondary={`Tool name: ${handoff.toolName}`}
                        />
                      </ListItem>
                    </React.Fragment>
                  ))}
                </List>
              </>
            )}
          </Paper>
        </Grid>
      </Grid>
      
      <Dialog
        open={openDialog}
        onClose={handleCloseDialog}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>
          Create Custom Handoff
        </DialogTitle>
        <DialogContent dividers>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Specialist Name"
                value={newHandoff.name}
                onChange={(e) => setNewHandoff({...newHandoff, name: e.target.value})}
                required
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Tool Name"
                value={newHandoff.toolName}
                onChange={(e) => setNewHandoff({...newHandoff, toolName: e.target.value})}
                helperText="This will be the name of the handoff tool used by the agent"
                required
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Description"
                value={newHandoff.description}
                onChange={(e) => setNewHandoff({...newHandoff, description: e.target.value})}
                multiline
                rows={2}
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>
            Cancel
          </Button>
          <Button 
            onClick={handleSaveHandoff} 
            variant="contained"
            disabled={!newHandoff.name || !newHandoff.toolName}
          >
            Add Handoff
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
}

export default HandoffsSelector;


================================================
FILE: src/components/builder/InstructionsEditor.js
================================================
import React, { useState } from 'react';
import Box from '@mui/material/Box';
import Paper from '@mui/material/Paper';
import Typography from '@mui/material/Typography';
import TextField from '@mui/material/TextField';
import ToggleButton from '@mui/material/ToggleButton';
import ToggleButtonGroup from '@mui/material/ToggleButtonGroup';
import Chip from '@mui/material/Chip';
import Alert from '@mui/material/Alert';
import Editor from '@monaco-editor/react';
import CodeIcon from '@mui/icons-material/Code';
import TextFormatIcon from '@mui/icons-material/TextFormat';
import FormatListBulletedIcon from '@mui/icons-material/FormatListBulleted';

// Example templates for instruction prompts
const instructionTemplates = [
  {
    id: 'customer-support',
    name: 'Customer Support',
    description: 'Handle customer inquiries, troubleshoot issues, and provide helpful responses',
    content: `You are a friendly customer support agent. Your goal is to help users with their inquiries about our products and services.

Follow these guidelines:
1. Be polite and professional at all times
2. Ask clarifying questions if the user's request is unclear
3. Provide concise, accurate information
4. Acknowledge when you don't know an answer
5. Use the tools available to you to lookup information when needed
6. Maintain a consistent, helpful tone throughout the conversation

You can handle:
- Product information requests
- Troubleshooting common issues
- Account management questions
- Billing inquiries
- General company information

If a request is complex or requires specialized knowledge, use the appropriate handoff to direct the user to a specialist.`
  },
  {
    id: 'content-creator',
    name: 'Content Creator',
    description: 'Produce engaging content following specific brand guidelines and tone',
    content: `You are a creative content writer for the brand. Your job is to create engaging, informative content that aligns with our brand voice and resonates with our audience.

Follow these guidelines:
1. Write in a conversational, approachable tone
2. Use clear, concise language that's easy to understand
3. Include engaging hooks and introductions
4. Incorporate relevant keywords naturally
5. Structure content with appropriate headings and sections
6. Back up claims with data and examples when possible

Brand voice:
- Friendly but professional
- Authoritative but not condescending
- Innovative and forward-thinking
- Inclusive and accessible

When writing, focus on providing value to the reader. Avoid overly promotional language and prioritize educational, insightful content.`
  },
  {
    id: 'data-analyst',
    name: 'Data Analyst',
    description: 'Analyze data, provide insights, and generate visualizations',
    content: `You are a data analyst assistant. Your role is to help users analyze and interpret data, providing clear insights and recommendations.

Follow these guidelines:
1. Ask for clarification about data sources and specific analysis needs
2. Provide objective, data-driven insights
3. Explain your methodology and reasoning
4. Present findings in clear, concise language
5. Suggest visualizations when appropriate
6. Highlight limitations in the data or analysis

When analyzing data:
- Consider statistical significance
- Look for trends and patterns
- Identify outliers and anomalies
- Consider contextual factors
- Provide actionable insights when possible

Avoid making claims that aren't supported by the data. If certain conclusions can't be drawn from the available information, clearly communicate these limitations.`
  }
];

function InstructionsEditor({ agentData, updateAgentData }) {
  const [editorMode, setEditorMode] = useState('text');
  const [showTemplates, setShowTemplates] = useState(false);

  const handleInstructionsChange = (value) => {
    updateAgentData('instructions', value);
  };

  const applyTemplate = (template) => {
    updateAgentData('instructions', template.content);
    setShowTemplates(false);
  };

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Agent Instructions
      </Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
        Define how your agent should behave and respond to user inputs. These instructions serve as the system prompt for your agent.
      </Typography>
      
      <Alert severity="info" sx={{ mb: 3 }}>
        Clear, detailed instructions help your agent respond appropriately. Include specific guidance about tone, limitations, and how to handle different types of requests.
      </Alert>
      
      <Box sx={{ mb: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <ToggleButtonGroup
          value={editorMode}
          exclusive
          onChange={(_, newMode) => newMode && setEditorMode(newMode)}
          size="small"
        >
          <ToggleButton value="text">
            <TextFormatIcon sx={{ mr: 1 }} />
            Text
          </ToggleButton>
          <ToggleButton value="code">
            <CodeIcon sx={{ mr: 1 }} />
            Code
          </ToggleButton>
        </ToggleButtonGroup>
        
        <Chip 
          icon={<FormatListBulletedIcon />} 
          label="Use Template" 
          clickable
          color={showTemplates ? "primary" : "default"}
          onClick={() => setShowTemplates(!showTemplates)}
        />
      </Box>
      
      {showTemplates && (
        <Box sx={{ mb: 3 }}>
          <Typography variant="subtitle2" gutterBottom>
            Instruction Templates
          </Typography>
          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 2 }}>
            {instructionTemplates.map((template) => (
              <Paper
                key={template.id}
                sx={{ 
                  p: 2, 
                  flexBasis: 'calc(33.33% - 16px)',
                  flexGrow: 0,
                  cursor: 'pointer',
                  '&:hover': {
                    boxShadow: 2
                  }
                }}
                onClick={() => applyTemplate(template)}
              >
                <Typography variant="subtitle2">{template.name}</Typography>
                <Typography variant="body2" color="text.secondary" noWrap>
                  {template.description}
                </Typography>
              </Paper>
            ))}
          </Box>
        </Box>
      )}
      
      <Box sx={{ height: 400, border: 1, borderColor: 'divider', borderRadius: 1 }}>
        {editorMode === 'text' ? (
          <TextField
            fullWidth
            multiline
            value={agentData.instructions}
            onChange={(e) => handleInstructionsChange(e.target.value)}
            placeholder="Enter detailed instructions for your agent..."
            variant="outlined"
            sx={{ 
              height: '100%',
              '& .MuiOutlinedInput-root': {
                height: '100%',
                alignItems: 'flex-start'
              },
              '& .MuiOutlinedInput-notchedOutline': {
                border: 'none'
              },
              '& .MuiInputBase-input': {
                height: '100%',
                overflowY: 'auto'
              }
            }}
          />
        ) : (
          <Editor
            height="100%"
            language="markdown"
            theme="light"
            value={agentData.instructions}
            onChange={handleInstructionsChange}
            options={{
              minimap: { enabled: false },
              lineNumbers: 'on',
              wordWrap: 'on',
              wrappingIndent: 'indent',
              scrollBeyondLastLine: false,
            }}
          />
        )}
      </Box>
    </Box>
  );
}

export default InstructionsEditor;


================================================
FILE: src/components/builder/TestAgent.js
================================================
import React, { useState, useRef, useEffect } from 'react';
import apiService from '../../utils/apiService';
import Box from '@mui/material/Box';
import Paper from '@mui/material/Paper';
import Typography from '@mui/material/Typography';
import TextField from '@mui/material/TextField';
import Button from '@mui/material/Button';
import Divider from '@mui/material/Divider';
import List from '@mui/material/List';
import ListItem from '@mui/material/ListItem';
import IconButton from '@mui/material/IconButton';
import Avatar from '@mui/material/Avatar';
import Alert from '@mui/material/Alert';
import CircularProgress from '@mui/material/CircularProgress';
import SendIcon from '@mui/icons-material/Send';
import SmartToyOutlinedIcon from '@mui/icons-material/SmartToyOutlined';
import PersonOutlineIcon from '@mui/icons-material/PersonOutline';
import InsertDriveFileOutlinedIcon from '@mui/icons-material/InsertDriveFileOutlined';
import ReplayIcon from '@mui/icons-material/Replay';
import DeleteOutlineIcon from '@mui/icons-material/DeleteOutline';

function TestAgent({ agentData }) {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef(null);

  // Scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSendMessage = async () => {
    if (!input.trim()) return;
    
    // Add user message
    const userMessage = {
      id: Date.now(),
      role: 'user',
      content: input
    };
    
    setMessages([...messages, userMessage]);
    setInput('');
    setIsLoading(true);
    
    try {
      // Check if API key exists
      const apiKey = localStorage.getItem('openai_api_key');
      if (!apiKey) {
        throw new Error('No API key found. Please set your OpenAI API key in the settings.');
      }
      
      // Add a processing message
      const processingMessage = {
        id: Date.now() + 0.1,
        role: 'system',
        content: 'Processing your request...'
      };
      setMessages(prev => [...prev, processingMessage]);
      
      // If we have an agent ID (saved agent), use it
      if (agentData.id) {
        console.log(`Running agent with ID: ${agentData.id}`);
        const response = await apiService.runAgent(agentData.id, input);
        
        // Remove the processing message
        setMessages(prev => prev.filter(m => m.id !== processingMessage.id));
        
        processAgentResponse(response);
      } else {
        // For unsaved agents, create a temporary agent
        console.log('Creating temporary agent...');
        const tempAgent = await apiService.createAgent(agentData);
        console.log(`Created temporary agent with ID: ${tempAgent.id}`);
        
        const response = await apiService.runAgent(tempAgent.id, input);
        
        // Remove the processing message
        setMessages(prev => prev.filter(m => m.id !== processingMessage.id));
        
        processAgentResponse(response);
      }
    } catch (error) {
      console.error('Error running agent:', error);
      
      // Remove any processing message
      setMessages(prev => prev.filter(m => m.content === 'Processing your request...'));
      
      // Handle errors
      const errorMessage = {
        id: Date.now(),
        role: 'system',
        content: `Error: ${error.message || 'Failed to get response from agent'}`
      };
      setMessages(prev => [...prev, errorMessage]);
      setIsLoading(false);
    }
  };
  
  /**
   * Process an agent response from the OpenAI Agents SDK
   */
  const processAgentResponse = (response) => {
    console.log('Processing agent response:', response);
    
    // Process tool calls if present
    if (response.new_items) {
      for (const item of response.new_items) {
        if (item.type === "tool_call_item") {
          // Add tool call message
          const toolCallMessage = {
            id: Date.now() + Math.random(),
            role: 'assistant',
            type: 'tool_call',
            tool: item.raw_item.name,
            content: `Using ${item.raw_item.name}...`
          };
          
          // Add tool result message
          const toolResultMessage = {
            id: Date.now() + Math.random(),
            role: 'tool',
            tool: item.raw_item.name,
            content: item.output || 'Tool execution completed'
          };
          
          setMessages(prev => [...prev, toolCallMessage, toolResultMessage]);
        }
      }
    }
    
    // Add the final assistant response
    let content = 'No response generated';
    
    if (typeof response.output === 'string') {
      content = response.output;
    } else if (response.final_output) {
      // Handle SDK's final_output
      if (typeof response.final_output === 'string') {
        content = response.final_output;
      } else if (typeof response.final_output === 'object') {
        content = JSON.stringify(response.final_output, null, 2);
      }
    } else if (response.output?.content) {
      content = response.output.content;
    } else if (response.output?.text) {
      content = response.output.text;
    } else if (response.content) {
      content = response.content;
    } else if (typeof response === 'string') {
      content = response;
    }
    
    const assistantMessage = {
      id: Date.now() + Math.random(),
      role: 'assistant',
      content: content
    };
    
    setMessages(prev => [...prev, assistantMessage]);
    setIsLoading(false);
  };

  const handleClearChat = () => {
    setMessages([]);
  };

  // Render messages with appropriate styling based on role
  const renderMessage = (message) => {
    switch (message.role) {
      case 'user':
        return (
          <ListItem key={message.id} sx={{ justifyContent: 'flex-end' }}>
            <Paper
              sx={{
                p: 2,
                bgcolor: 'primary.main',
                color: 'white',
                borderRadius: '12px 12px 0 12px',
                maxWidth: '80%'
              }}
            >
              <Typography variant="body1">{message.content}</Typography>
            </Paper>
          </ListItem>
        );
        
      case 'assistant':
        if (message.type === 'tool_call') {
          return (
            <ListItem key={message.id}>
              <Avatar sx={{ bgcolor: 'secondary.light', mr: 2 }}>
                <SmartToyOutlinedIcon />
              </Avatar>
              <Paper
                sx={{
                  p: 2,
                  bgcolor: 'background.paper',
                  border: '1px solid',
                  borderColor: 'divider',
                  borderRadius: '12px 12px 12px 0',
                  maxWidth: '80%'
                }}
              >
                <Typography variant="body2" color="text.secondary" gutterBottom>
                  Using tool: {message.tool}
                </Typography>
                <Typography variant="body1">{message.content}</Typography>
              </Paper>
            </ListItem>
          );
        }
        
        return (
          <ListItem key={message.id}>
            <Avatar sx={{ bgcolor: 'primary.light', mr: 2 }}>
              <SmartToyOutlinedIcon />
            </Avatar>
            <Paper
              sx={{
                p: 2,
                bgcolor: 'background.paper',
                border: '1px solid',
                borderColor: 'divider',
                borderRadius: '12px 12px 12px 0',
                maxWidth: '80%'
              }}
            >
              <Typography variant="body1">{message.content}</Typography>
            </Paper>
          </ListItem>
        );
        
      case 'tool':
        return (
          <ListItem key={message.id}>
            <Avatar sx={{ bgcolor: 'info.light', mr: 2 }}>
              <InsertDriveFileOutlinedIcon />
            </Avatar>
            <Paper
              sx={{
                p: 2,
                bgcolor: theme => theme.palette.mode === 'dark' ? 'background.paper' : 'info.50',
                border: '1px solid',
                borderColor: theme => theme.palette.mode === 'dark' ? 'divider' : 'info.200',
                borderRadius: '12px 12px 12px 0',
                maxWidth: '80%'
              }}
            >
              <Typography variant="body2" color="text.secondary" gutterBottom>
                Tool result: {message.tool}
              </Typography>
              <Typography variant="body1">{message.content}</Typography>
            </Paper>
          </ListItem>
        );
        
      case 'specialist':
        return (
          <ListItem key={message.id}>
            <Avatar sx={{ bgcolor: 'secondary.main', mr: 2 }}>
              <PersonOutlineIcon />
            </Avatar>
            <Paper
              sx={{
                p: 2,
                bgcolor: theme => theme.palette.mode === 'dark' ? 'background.paper' : 'secondary.50',
                border: '1px solid',
                borderColor: theme => theme.palette.mode === 'dark' ? 'divider' : 'secondary.200',
                borderRadius: '12px 12px 12px 0',
                maxWidth: '80%'
              }}
            >
              <Typography variant="body2" color="secondary" fontWeight="bold" gutterBottom>
                {message.name}
              </Typography>
              <Typography variant="body1">{message.content}</Typography>
            </Paper>
          </ListItem>
        );
        
      case 'system':
        return (
          <ListItem key={message.id} sx={{ justifyContent: 'center' }}>
            <Paper
              sx={{
                py: 1,
                px: 2,
                bgcolor: theme => theme.palette.mode === 'dark' ? 'background.paper' : 'grey.100',
                border: '1px solid',
                borderColor: theme => theme.palette.mode === 'dark' ? 'divider' : 'grey.300',
                borderRadius: '12px',
              }}
            >
              <Typography variant="caption" color="text.secondary">
                {message.content}
              </Typography>
            </Paper>
          </ListItem>
        );
        
      default:
        return null;
    }
  };

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Test Your Agent
      </Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
        Test how your agent responds to different inputs. This environment uses the OpenAI Agents SDK to provide real responses based on your agent configuration.
      </Typography>
      
      <Paper sx={{ mb: 3 }} elevation={3}>
        <Box sx={{ p: 2, bgcolor: 'primary.main', color: 'white', display: 'flex', alignItems: 'center' }}>
          <SmartToyOutlinedIcon sx={{ mr: 1 }} />
          <Typography variant="subtitle1">
            {agentData.name || 'Agent'} - Test Chat
          </Typography>
          <Box sx={{ flexGrow: 1 }} />
          <IconButton
            size="small"
            color="inherit"
            onClick={handleClearChat}
            title="Clear chat"
          >
            <DeleteOutlineIcon fontSize="small" />
          </IconButton>
        </Box>
        
        <Box
          sx={{
            height: 400,
            overflowY: 'auto',
            bgcolor: theme => theme.palette.mode === 'dark' ? 'background.paper' : 'grey.50',
            p: 2
          }}
        >
          {messages.length === 0 ? (
            <Box
              sx={{
                height: '100%',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center',
                alignItems: 'center',
                color: 'text.secondary'
              }}
            >
              <SmartToyOutlinedIcon sx={{ fontSize: 48, mb: 2, color: 'primary.main' }} />
              <Typography variant="body1" gutterBottom>
                No messages yet
              </Typography>
              <Typography variant="body2">
                Start a conversation to test your agent
              </Typography>
              <Button
                variant="outlined"
                size="small"
                startIcon={<ReplayIcon />}
                sx={{ mt: 2 }}
                onClick={() => {
                  setInput("Hi! What can you help me with?");
                }}
              >
                Suggest a prompt
              </Button>
            </Box>
          ) : (
            <List sx={{ p: 0 }}>
              {messages.map(message => renderMessage(message))}
              <div ref={messagesEndRef} />
            </List>
          )}
        </Box>
        
        <Divider />
        
        <Box sx={{ p: 2, display: 'flex' }}>
          <TextField
            fullWidth
            placeholder="Type your message..."
            variant="outlined"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleSendMessage();
              }
            }}
            disabled={isLoading}
            size="small"
            sx={{ mr: 1 }}
          />
          <Button
            variant="contained"
            color="primary"
            onClick={handleSendMessage}
            disabled={!input.trim() || isLoading}
            sx={{ minWidth: 0, p: 1 }}
          >
            {isLoading ? <CircularProgress size={24} /> : <SendIcon />}
          </Button>
        </Box>
      </Paper>
      
      <Alert severity="info">
        <Typography variant="body2">
          This test environment connects to the OpenAI API using the Agents SDK and your API key. For saved agents, you'll get real responses from the SDK. For unsaved agents, a temporary agent will be created.
        </Typography>
      </Alert>
    </Box>
  );
}

export default TestAgent;


================================================
FILE: src/components/builder/ToolsSelector.js
================================================
import React, { useState } from 'react';
import Box from '@mui/material/Box';
import Grid from '@mui/material/Grid';
import Paper from '@mui/material/Paper';
import Typography from '@mui/material/Typography';
import List from '@mui/material/List';
import ListItem from '@mui/material/ListItem';
import ListItemText from '@mui/material/ListItemText';
import ListItemIcon from '@mui/material/ListItemIcon';
import Divider from '@mui/material/Divider';
import Chip from '@mui/material/Chip';
import Button from '@mui/material/Button';
import TextField from '@mui/material/TextField';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import IconButton from '@mui/material/IconButton';
import Tooltip from '@mui/material/Tooltip';
import Tabs from '@mui/material/Tabs';
import Tab from '@mui/material/Tab';
import SearchIcon from '@mui/icons-material/Search';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import CodeIcon from '@mui/icons-material/Code';
import PublicIcon from '@mui/icons-material/Public';
import DescriptionIcon from '@mui/icons-material/Description';
import ExtensionIcon from '@mui/icons-material/Extension';
import HelpOutlineIcon from '@mui/icons-material/HelpOutline';
import Editor from '@monaco-editor/react';

import { builtInTools, exampleFunctionTools } from '../../utils/tools';
import { fullToolExampleTemplate } from '../../utils/codeTemplates';

function ToolsSelector({ agentData, updateAgentData }) {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedTab, setSelectedTab] = useState(0);
  const [openDialog, setOpenDialog] = useState(false);
  const [currentTool, setCurrentTool] = useState(null);
  const [toolCode, setToolCode] = useState('');

  const handleAddTool = (tool) => {
    const updatedTools = [...agentData.tools, tool];
    updateAgentData('tools', updatedTools);
  };

  const handleRemoveTool = (toolId) => {
    const updatedTools = agentData.tools.filter(tool => tool.id !== toolId);
    updateAgentData('tools', updatedTools);
  };

  const handleOpenToolDialog = (tool = null) => {
    if (tool) {
      setCurrentTool(tool);
      setToolCode(tool.code || '');
    } else {
      setCurrentTool(null);
      setToolCode(fullToolExampleTemplate);
    }
    setOpenDialog(true);
  };

  const handleCloseToolDialog = () => {
    setOpenDialog(false);
  };

  const handleSaveCustomTool = () => {
    // In a real app, this would validate and save the custom tool
    // For now, we'll just close the dialog
    setOpenDialog(false);
  };

  const getToolIcon = (category) => {
    switch (category) {
      case 'Built-in':
        return <ExtensionIcon />;
      case 'Function':
        return <CodeIcon />;
      case 'Web':
        return <PublicIcon />;
      case 'File':
        return <DescriptionIcon />;
      default:
        return <ExtensionIcon />;
    }
  };

  const filteredBuiltInTools = builtInTools.filter(
    tool => tool.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            tool.description.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const filteredFunctionTools = exampleFunctionTools.filter(
    tool => tool.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            tool.description.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Agent Tools
      </Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
        Select the tools your agent can use to perform tasks. Tools enable your agent to interact with external systems and APIs.
      </Typography>
      
      <Grid container spacing={3}>
        <Grid item xs={12} md={7}>
          <Paper sx={{ height: '100%', p: 2 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
              <TextField
                size="small"
                placeholder="Search tools..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                InputProps={{
                  startAdornment: <SearchIcon color="action" sx={{ mr: 1 }} />,
                }}
                sx={{ flexGrow: 1, mr: 2 }}
              />
              <Button
                variant="contained"
                startIcon={<AddIcon />}
                onClick={() => handleOpenToolDialog()}
                size="small"
              >
                Custom Tool
              </Button>
            </Box>
            
            <Tabs 
              value={selectedTab} 
              onChange={(_, newValue) => setSelectedTab(newValue)}
              sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}
            >
              <Tab label="Built-in Tools" />
              <Tab label="Function Examples" />
            </Tabs>
            
            {selectedTab === 0 && (
              <List>
                {filteredBuiltInTools.map((tool) => {
                  const isAdded = agentData.tools.some(t => t.id === tool.id);
                  
                  return (
                    <ListItem 
                      key={tool.id}
                      className="tool-item"
                      secondaryAction={
                        isAdded ? (
                          <IconButton 
                            edge="end" 
                            aria-label="remove" 
                            color="error"
                            onClick={() => handleRemoveTool(tool.id)}
                          >
                            <DeleteIcon />
                          </IconButton>
                        ) : (
                          <Button
                            variant="outlined"
                            size="small"
                            onClick={() => handleAddTool(tool)}
                          >
                            Add
                          </Button>
                        )
                      }
                    >
                      <ListItemIcon>
                        {getToolIcon(tool.category)}
                      </ListItemIcon>
                      <ListItemText
                        primary={
                          <Box sx={{ display: 'flex', alignItems: 'center' }}>
                            {tool.name}
                            {isAdded && (
                              <Chip 
                                label="Added" 
                                color="primary" 
                                size="small" 
                                sx={{ ml: 1 }}
                              />
                            )}
                          </Box>
                        }
                        secondary={tool.description}
                      />
                    </ListItem>
                  );
                })}
              </List>
            )}
            
            {selectedTab === 1 && (
              <List>
                {filteredFunctionTools.map((tool) => {
                  const isAdded = agentData.tools.some(t => t.id === tool.id);
                  
                  return (
                    <ListItem 
                      key={tool.id}
                      className="tool-item"
                      secondaryAction={
                        <Box>
                          <Tooltip title="View Code">
                            <IconButton
                              edge="end"
                              aria-label="view code"
                              sx={{ mr: 1 }}
                              onClick={() => handleOpenToolDialog(tool)}
                            >
                              <CodeIcon />
                            </IconButton>
                          </Tooltip>
                          
                          {isAdded ? (
                            <IconButton 
                              edge="end" 
                              aria-label="remove" 
                              color="error"
                              onClick={() => handleRemoveTool(tool.id)}
                            >
                              <DeleteIcon />
                            </IconButton>
                          ) : (
                            <Button
                              variant="outlined"
                              size="small"
                              onClick={() => handleAddTool(tool)}
                            >
                              Add
                            </Button>
                          )}
                        </Box>
                      }
                    >
                      <ListItemIcon>
                        {getToolIcon(tool.category)}
                      </ListItemIcon>
                      <ListItemText
                        primary={
                          <Box sx={{ display: 'flex', alignItems: 'center' }}>
                            {tool.name}
                            {isAdded && (
                              <Chip 
                                label="Added" 
                                color="primary" 
                                size="small" 
                                sx={{ ml: 1 }}
                              />
                            )}
                          </Box>
                        }
                        secondary={tool.description}
                      />
                    </ListItem>
                  );
                })}
              </List>
            )}
          </Paper>
        </Grid>
        
        <Grid item xs={12} md={5}>
          <Paper sx={{ p: 2, height: '100%' }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
              <Typography variant="h6">
                Selected Tools
              </Typography>
              <Tooltip title="Tool usage information">
                <IconButton size="small">
                  <HelpOutlineIcon />
                </IconButton>
              </Tooltip>
            </Box>
            
            {agentData.tools.length === 0 ? (
              <Box 
                sx={{ 
                  p: 3, 
                  textAlign: 'center', 
                  border: '1px dashed', 
                  borderColor: 'grey.300',
                  borderRadius: 1
                }}
              >
                <Typography variant="body2" color="text.secondary">
                  No tools selected yet. Add tools from the left panel to enhance your agent's capabilities.
                </Typography>
              </Box>
            ) : (
              <List>
                {agentData.tools.map((tool, index) => (
                  <React.Fragment key={tool.id}>
                    {index > 0 && <Divider />}
                    <ListItem
                      secondaryAction={
                        <IconButton 
                          edge="end" 
                          aria-label="remove" 
                          color="error"
                          onClick={() => handleRemoveTool(tool.id)}
                        >
                          <DeleteIcon />
                        </IconButton>
                      }
                    >
                      <ListItemIcon>
                        {getToolIcon(tool.category)}
                      </ListItemIcon>
                      <ListItemText
                        primary={tool.name}
                        secondary={tool.category}
                      />
                    </ListItem>
                  </React.Fragment>
                ))}
              </List>
            )}
          </Paper>
        </Grid>
      </Grid>
      
      <Dialog
        open={openDialog}
        onClose={handleCloseToolDialog}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {currentTool ? `Tool: ${currentTool.name}` : 'Create Custom Tool'}
        </DialogTitle>
        <DialogContent dividers>
          {currentTool && (
            <Box sx={{ mb: 2 }}>
              <Typography variant="subtitle2">Description:</Typography>
              <Typography variant="body2" paragraph>
                {currentTool.description}
              </Typography>
            </Box>
          )}
          
          <Box sx={{ height: 400 }}>
            <Editor
              height="100%"
              language="python"
              theme="light"
              value={toolCode}
              onChange={setToolCode}
              options={{
                readOnly: !!currentTool,
                minimap: { enabled: false },
                scrollBeyondLastLine: false,
              }}
            />
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseToolDialog}>
            {currentTool ? 'Close' : 'Cancel'}
          </Button>
          {!currentTool && (
            <Button 
              onClick={handleSaveCustomTool} 
              variant="contained"
            >
              Save Tool
            </Button>
          )}
        </DialogActions>
      </Dialog>
    </Box>
  );
}

export default ToolsSelector;


================================================
FILE: src/styles/index.css
================================================
body {
  margin: 0;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

.container {
  padding: 24px;
}

.card {
  transition: box-shadow 0.3s ease, transform 0.3s ease;
}

.card:hover {
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
  transform: translateY(-4px);
}

.tool-item {
  border-left: 4px solid transparent;
  transition: border-color 0.2s ease, background-color 0.2s ease;
}

.tool-item:hover {
  border-left-color: #10A37F;
  background-color: rgba(16, 163, 127, 0.05);
}

.editor-container {
  border-radius: 8px;
  overflow: hidden;
}


================================================
FILE: src/utils/apiService.js
================================================
// Import the OpenAI Agents SDK
import { OpenAI, OpenAIAgent } from 'openai-agents';

// Local storage keys
const STORAGE_KEY_AGENTS = 'openai_agents';
const STORAGE_KEY_API_KEY = 'openai_api_key';

class ApiService {
  constructor() {
    // Initialize local storage for agents if not exists
    if (!localStorage.getItem(STORAGE_KEY_AGENTS)) {
      localStorage.setItem(STORAGE_KEY_AGENTS, JSON.stringify([]));
    }
    
    // Set up the OpenAI API key from local storage
    this.setupApiKey();
  }
  
  /**
   * Set up the OpenAI API key from local storage
   */
  setupApiKey() {
    const apiKey = localStorage.getItem(STORAGE_KEY_API_KEY);
    if (apiKey) {
      // Initialize OpenAI client with the API key
      this.openai = new OpenAI({
        apiKey: apiKey,
        dangerouslyAllowBrowser: true // Required for browser usage
      });
    }
  }

  /**
   * Create a new agent
   * @param {Object} agentData - The agent configuration
   * @returns {Promise<Object>} - The created agent
   */
  async createAgent(agentData) {
    try {
      // Create an OpenAIAgent instance
      const agent = new OpenAIAgent({
        name: agentData.name,
        instructions: agentData.instructions,
        model: agentData.model || 'gpt-4o',
        // Note: OpenAIAgent has a different API than the original Agent class
        // We're simplifying here and will need to adapt as needed
      });
      
      // Convert the Agent instance to our internal format
      const createdAgent = this._convertAgentToInternalFormat(agent, agentData);
      
      // Save to local storage
      this._saveAgentToLocalStorage(createdAgent);
      
      return createdAgent;
    } catch (error) {
      console.error('Error creating agent:', error);
      
      // If SDK calls fail, create a local-only agent
      const localAgent = this._createLocalAgent(agentData);
      this._saveAgentToLocalStorage(localAgent);
      
      return localAgent;
    }
  }
  
  /**
   * Update an existing agent
   * @param {string} agentId - The ID of the agent to update
   * @param {Object} agentData - The updated agent configuration
   * @returns {Promise<Object>} - The updated agent
   */
  async updateAgent(agentId, agentData) {
    try {
      // Create an updated OpenAIAgent instance
      const agent = new OpenAIAgent({
        name: agentData.name,
        instructions: agentData.instructions,
        model: agentData.model || 'gpt-4o',
        // Note: OpenAIAgent has a different API than the original Agent class
        // We're simplifying here and will need to adapt as needed
      });
      
      // Convert the Agent instance to our internal format and preserve the ID
      const updatedAgent = {
        ...this._convertAgentToInternalFormat(agent, agentData),
        id: agentId,
        updated_at: new Date().toISOString()
      };
      
      // Save to local storage
      this._saveAgentToLocalStorage(updatedAgent);
      
      return updatedAgent;
    } catch (error) {
      console.error('Error updating agent:', error);
      
      // If SDK calls fail, update in local storage only
      const updatedAgent = {
        ...agentData,
        id: agentId,
        updated_at: new Date().toISOString()
      };
      
      this._saveAgentToLocalStorage(updatedAgent);
      
      return updatedAgent;
    }
  }
  
  /**
   * Get all agents
   * @returns {Promise<Array>} - List of agents
   */
  async getAgents() {
    // Return agents from local storage
    return this._getAgentsFromLocalStorage();
  }
  
  /**
   * Delete an agent
   * @param {string} agentId - The ID of the agent to delete
   * @returns {Promise<boolean>} - Whether the deletion was successful
   */
  async deleteAgent(agentId) {
    try {
      // Remove from local storage
      const agents = this._getAgentsFromLocalStorage();
      const updatedAgents = agents.filter(agent => agent.id !== agentId);
      localStorage.setItem(STORAGE_KEY_AGENTS, JSON.stringify(updatedAgents));
      
      return true;
    } catch (error) {
      console.error('Error deleting agent:', error);
      return false;
    }
  }
  
  /**
   * Run an agent with the provided input
   * @param {string} agentId - The ID of the agent to run
   * @param {string|Array} input - The input message or conversation history
   * @returns {Promise<Object>} - The run result
   */
  async runAgent(agentId, input) {
    // Format the input based on whether it's a string or array
    const formattedInput = typeof input === 'string'
      ? input
      : input[input.length - 1].content; // Use the last message content
    
    // Check if we have a valid API key before proceeding
    const apiKey = localStorage.getItem(STORAGE_KEY_API_KEY);
    if (!apiKey) {
      throw new Error('No API key found. Please set your OpenAI API key in the settings.');
    }
    
    try {
      // Get the agent from local storage
      const agents = this._getAgentsFromLocalStorage();
      const agentData = agents.find(a => a.id === agentId);
      
      if (!agentData) {
        throw new Error(`Agent with ID ${agentId} not found`);
      }
      
      // Initialize OpenAI client if not already done
      if (!this.openai) {
        this.openai = new OpenAI({
          apiKey: apiKey,
          dangerouslyAllowBrowser: true
        });
      }
      
      // Prepare tools if the agent has any
      const tools = this._createToolsFromConfig(agentData.tools || []);
      
      // Create a chat completion using the OpenAI API
      const messages = [
        { role: 'system', content: agentData.instructions },
        { role: 'user', content: formattedInput }
      ];
      
      // Create the API request
      const requestOptions = {
        model: agentData.model || 'gpt-4o',
        messages: messages,
        temperature: agentData.modelSettings?.temperature || 0.7,
        top_p: agentData.modelSettings?.topP || 1,
        frequency_penalty: agentData.modelSettings?.frequencyPenalty || 0,
        presence_penalty: agentData.modelSettings?.presencePenalty || 0,
      };
      
      // Add tools if available
      if (tools.length > 0) {
        requestOptions.tools = tools;
        requestOptions.tool_choice = 'auto';
      }
      
      // Make the API call
      const response = await this.openai.chat.completions.create(requestOptions);
      
      // Process the response
      const responseMessage = response.choices[0].message;
      let finalOutput = responseMessage.content || '';
      const newItems = [];
      
      // Handle tool calls if present
      if (responseMessage.tool_calls && responseMessage.tool_calls.length > 0) {
        // Process each tool call
        for (const toolCall of responseMessage.tool_calls) {
          const toolName = toolCall.function.name;
          const toolArgs = JSON.parse(toolCall.function.arguments);
          
          // Add tool call to new items
          newItems.push({
            type: 'tool_call_item',
            raw_item: {
              name: toolName,
              arguments: toolCall.function.arguments
            }
          });
          
          // Handle different tools
          let toolResult = '';
          if (toolName === 'web_search') {
            // Provide realistic simulated web search results for weather queries
            const query = toolArgs.query.toLowerCase();
            
            if (query.includes('weather') || query.includes('temperature') || query.includes('forecast')) {
              // Extract location from query
              let location = 'the requested location';
              const locationMatch = query.match(/(?:weather|temperature|forecast)(?:\s+in|\s+for|\s+at)?\s+([a-zA-Z\s,]+)/i);
              if (locationMatch && locationMatch[1]) {
                location = locationMatch[1].trim();
              }
              
              // Generate realistic weather data
              const currentDate = new Date();
              const temperature = Math.floor(Math.random() * 30) + 40; // Random temp between 40-70¬∞F
              const conditions = ['Sunny', 'Partly Cloudy', 'Cloudy', 'Rainy', 'Snowy'][Math.floor(Math.random() * 5)];
              const humidity = Math.floor(Math.random() * 50) + 30; // Random humidity between 30-80%
              const windSpeed = Math.floor(Math.random() * 20) + 5; // Random wind speed between 5-25 mph
              
              toolResult = `Weather search results for "${location}":\n\n` +
                `Current Weather for ${location} (as of ${currentDate.toLocaleTimeString()}):\n` +
                `- Temperature: ${temperature}¬∞F\n` +
                `- Conditions: ${conditions}\n` +
                `- Humidity: ${humidity}%\n` +
                `- Wind Speed: ${windSpeed} mph\n\n` +
                `5-Day Forecast for ${location}:\n` +
                `- Today: ${conditions}, High ${temperature}¬∞F, Low ${temperature-10}¬∞F\n` +
                `- Tomorrow: ${['Sunny', 'Partly Cloudy', 'Cloudy', 'Rainy', 'Snowy'][Math.floor(Math.random() * 5)]}, High ${temperature+2}¬∞F, Low ${temperature-8}¬∞F\n` +
                `- Day 3: ${['Sunny', 'Partly Cloudy', 'Cloudy', 'Rainy', 'Snowy'][Math.floor(Math.random() * 5)]}, High ${temperature-5}¬∞F, Low ${temperature-15}¬∞F\n` +
                `- Day 4: ${['Sunny', 'Partly Cloudy', 'Cloudy', 'Rainy', 'Snowy'][Math.floor(Math.random() * 5)]}, High ${temperature+4}¬∞F, Low ${temperature-6}¬∞F\n` +
                `- Day 5: ${['Sunny', 'Partly Cloudy', 'Cloudy', 'Rainy', 'Snowy'][Math.floor(Math.random() * 5)]}, High ${temperature+1}¬∞F, Low ${temperature-9}¬∞F\n\n` +
                `Source: Simulated Weather Data (for demonstration purposes)`;
            } else {
              // Generic search results for non-weather queries
              toolResult = `Search results for "${toolArgs.query}":\n\n` +
                `1. ${toolArgs.query} - Wikipedia\n   Summary: Information about ${toolArgs.query} from the free encyclopedia...\n\n` +
                `2. Latest news on ${toolArgs.query} - News Source\n   Summary: Recent developments related to ${toolArgs.query}...\n\n` +
                `3. Understanding ${toolArgs.query} - Educational Resource\n   Summary: Comprehensive guide to understanding ${toolArgs.query}...\n\n` +
                `Source: Simulated Search Results (for demonstration purposes)`;
            }
          } else if (toolName === 'file_search') {
            toolResult = `File search results for "${toolArgs.query}":\n\n` +
              `1. document1.pdf - Relevance: High\n   Context: ...information related to ${toolArgs.query}...\n\n` +
              `2. presentation.pptx - Relevance: Medium\n   Context: ...mentions ${toolArgs.query} in the context of...\n\n` +
              `3. notes.txt - Relevance: Medium\n   Context: ...discussion about ${toolArgs.query} and related topics...\n\n` +
              `Source: Simulated File Search (for demonstration purposes)`;
          } else {
            toolResult = `Tool ${toolName} was called with arguments: ${toolCall.function.arguments}`;
          }
          
          // Add tool result to new items
          newItems.push({
            type: 'tool_call_output_item',
            output: toolResult
          });
          
          // Add the tool result to the conversation
          messages.push({
            role: 'assistant',
            tool_calls: [toolCall]
          });
          
          messages.push({
            role: 'tool',
            tool_call_id: toolCall.id,
            content: toolResult
          });
        }
        
        // Get a final response after tool use
        const finalResponse = await this.openai.chat.completions.create({
          model: agentData.model || 'gpt-4o',
          messages: messages,
          temperature: agentData.modelSettings?.temperature || 0.7,
        });
        
        finalOutput = finalResponse.choices[0].message.content || '';
        
        // Add the final message to new items
        newItems.push({
          type: 'message_output_item',
          raw_item: {
            content: finalOutput
          }
        });
      }
      
      // Update last used time for the agent
      agentData.last_used = new Date().toISOString();
      agentData.lastUsed = 'Just now';
      this._saveAgentToLocalStorage(agentData);
      
      // Format the response
      return {
        id: `run-${Date.now()}`,
        agent_id: agentId,
        status: 'completed',
        input: input,
        output: finalOutput,
        final_output: finalOutput,
        new_items: newItems
      };
    } catch (error) {
      console.error('Error running agent:', error);
      
      // Provide more detailed error messages
      if (error.message.includes('Network Error')) {
        throw new Error('Network error connecting to OpenAI API. Please check your internet connection and firewall settings.');
      } else if (error.message.includes('timeout')) {
        throw new Error('Request to OpenAI API timed out. The service might be experiencing high load.');
      } else if (error.message.includes('401')) {
        throw new Error('Invalid API key. Please check your OpenAI API key in the settings.');
      } else if (error.message.includes('429')) {
        throw new Error('Rate limit exceeded. Your OpenAI API key has reached its request limit.');
      } else if (error.message.includes('500')) {
        throw new Error('OpenAI API server error. Please try again later.');
      } else {
        throw new Error(`Failed to run agent: ${error.message || 'Unknown error'}`);
      }
    }
  }
  
  /**
   * Validates an OpenAI API key
   * @param {string} apiKey - The API key to validate
   * @returns {Promise<boolean>} - Whether the key is valid
   */
  async validateApiKey(apiKey) {
    try {
      if (!apiKey || !apiKey.startsWith('sk-')) {
        throw new Error('Invalid API key format');
      }
      
      // Create a temporary OpenAI client to test the API key
      const openai = new OpenAI({
        apiKey: apiKey,
        dangerouslyAllowBrowser: true
      });
      
      // Make a simple API call to test the key
      await openai.models.list();
      
      // If we get here, the key is valid
      return true;
    } catch (error) {
      console.error('Error validating API key:', error);
      throw new Error('Invalid API key: ' + error.message);
    }
  }
  
  // Helper methods
  
  /**
   * Create tools from configuration
   * @private
   */
  _createToolsFromConfig(toolsConfig) {
    if (!toolsConfig || !toolsConfig.length) return [];
    
    // Convert our tool configurations to OpenAI function calling format
    return toolsConfig.map(tool => {
      if (tool.name === 'WebSearchTool') {
        // Implement web search as a function
        return {
          type: 'function',
          function: {
            name: 'web_search',
            description: 'Search the web for information',
            parameters: {
              type: 'object',
              properties: {
                query: {
                  type: 'string',
                  description: 'The search query'
                }
              },
              required: ['query']
            }
          }
        };
      } else if (tool.name === 'FileSearchTool') {
        // Implement file search as a function
        return {
          type: 'function',
          function: {
            name: 'file_search',
            description: 'Search through vector stores of documents',
            parameters: {
              type: 'object',
              properties: {
                query: {
                  type: 'string',
                  description: 'The search query'
                },
                max_results: {
                  type: 'number',
                  description: 'Maximum number of results to return'
                }
              },
              required: ['query']
            }
          }
        };
      } else {
        // Function tool - create a function definition
        return {
          type: 'function',
          function: {
            name: tool.name,
            description: tool.description || '',
            parameters: this._buildJsonSchemaForTool(tool)
          }
        };
      }
    });
  }
  
  /**
   * Create handoffs from configuration
   * @private
   */
  _createHandoffsFromConfig(handoffsConfig) {
    // Simplified implementation since OpenAIAgent has a different API
    return handoffsConfig || [];
  }
  
  /**
   * Create guardrails from configuration
   * @private
   */
  _createGuardrailsFromConfig(guardrailsConfig) {
    // Simplified implementation since OpenAIAgent has a different API
    return guardrailsConfig || [];
  }
  
  /**
   * Build JSON schema for tool parameters
   * @private
   */
  _buildJsonSchemaForTool(tool) {
    if (!tool.parameters) return { type: 'object', properties: {} };
    
    const properties = {};
    const required = [];
    
    Object.entries(tool.parameters).forEach(([name, param]) => {
      if (name !== 'max_num_results' && name !== 'vector_store_ids') {
        properties[name] = {
          type: param.type || 'string',
          description: param.description || ''
        };
        
        if (param.required) {
          required.push(name);
        }
      }
    });
    
    return {
      type: 'object',
      properties,
      required: required.length > 0 ? required : undefined
    };
  }
  
  /**
   * Convert an Agent instance to our internal format
   * @private
   */
  _convertAgentToInternalFormat(agent, agentData) {
    return {
      id: `agent-${Date.now()}`,
      name: agent.name,
      description: agentData.description || '',
      model: agentData.model || 'gpt-4o',
      instructions: agentData.instructions,
      tools: agentData.tools || [],
      handoffs: agentData.handoffs || [],
      modelSettings: agentData.modelSettings || {
        temperature: 0.7,
        topP: 1,
        frequencyPenalty: 0,
        presencePenalty: 0
      },
      created_at: new Date().toISOString(),
      last_used: new Date().toISOString(),
      lastUsed: 'Just now'
    };
  }
  
  /**
   * Create a local-only agent
   * @private
   */
  _createLocalAgent(agentData) {
    return {
      id: `agent-${Date.now()}`,
      ...agentData,
      created_at: new Date().toISOString(),
      last_used: new Date().toISOString(),
      lastUsed: 'Just now'
    };
  }
  
  /**
   * Save an agent to local storage
   * @private
   */
  _saveAgentToLocalStorage(agent) {
    const agents = this._getAgentsFromLocalStorage();
    const existingIndex = agents.findIndex(a => a.id === agent.id);
    
    if (existingIndex >= 0) {
      agents[existingIndex] = agent;
    } else {
      agents.push(agent);
    }
    
    localStorage.setItem(STORAGE_KEY_AGENTS, JSON.stringify(agents));
  }
  
  /**
   * Get agents from local storage
   * @private
   */
  _getAgentsFromLocalStorage() {
    const agentsJson = localStorage.getItem(STORAGE_KEY_AGENTS);
    return agentsJson ? JSON.parse(agentsJson) : [];
  }
  
  /**
   * Get a relative time string (e.g., "2 hours ago")
   * @private
   */
  _getRelativeTimeString(date) {
    const now = new Date();
    const diffMs = now - date;
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHour = Math.floor(diffMin / 60);
    const diffDay = Math.floor(diffHour / 24);
    
    if (diffSec < 60) return 'Just now';
    if (diffMin < 60) return `${diffMin} minute${diffMin > 1 ? 's' : ''} ago`;
    if (diffHour < 24) return `${diffHour} hour${diffHour > 1 ? 's' : ''} ago`;
    if (diffDay < 7) return `${diffDay} day${diffDay > 1 ? 's' : ''} ago`;
    
    return date.toLocaleDateString();
  }
}

// Create a named instance
const apiServiceInstance = new ApiService();

// Export the instance
export default apiServiceInstance;


================================================
FILE: src/utils/codeTemplates.js
================================================
export const agentTemplate = `from agents import Agent, ModelSettings

agent = Agent(
    name="{{name}}",
    instructions="{{instructions}}",
    model="{{model}}",
    tools=[{{tools}}],
    handoffs=[{{handoffs}}],
)
`;

export const functionToolTemplate = `from agents import function_tool

@function_tool
def {{name}}({{parameters}}) -> str:
    """{{description}}
    
    Args:
        {{args_docs}}
    """
    # Implementation
    {{implementation}}
`;

export const structuredOutputTemplate = `from pydantic import BaseModel

class {{className}}(BaseModel):
    {{fields}}

agent = Agent(
    name="{{name}}",
    instructions="{{instructions}}",
    output_type={{className}},
)
`;

export const guardrailTemplate = `from agents import Agent, GuardrailFunctionOutput, input_guardrail

@input_guardrail
async def content_filter(ctx, agent, input):
    # Check input
    is_inappropriate = False  # Replace with actual check
    
    return GuardrailFunctionOutput(
        output_info={"reason": "Contains inappropriate content"},
        tripwire_triggered=is_inappropriate,
    )

agent = Agent(
    name="{{name}}",
    instructions="{{instructions}}",
    input_guardrails=[content_filter],
)
`;

export const runnerTemplate = `from agents import Runner

# Async version
result = await Runner.run(agent, "{{prompt}}")

# Access results
print(result.final_output)
`;

export const streamingTemplate = `from agents import Runner

stream_result = Runner.run_streamed(agent, "{{prompt}}")

async for event in stream_result.stream_events():
    if event.type == "run_item_stream_event":
        if event.item.type == "message_output_item":
            print("Message:", event.item.raw_item.content)
        elif event.item.type == "tool_call_item":
            print("Tool call:", event.item.raw_item.name)
`;

export const fullToolExampleTemplate = `from agents import function_tool
from typing import Dict, Any, List

@function_tool
def get_weather(city: str, days: int = 1) -> Dict[str, Any]:
    """Get weather forecast for a city.
    
    Args:
        city: The city to get weather for.
        days: Number of days to forecast (default: 1).
    
    Returns:
        Dict containing weather data.
    """
    # This would normally call a weather API
    # Sample implementation:
    return {
        "city": city,
        "forecast": [
            {"day": 1, "condition": "Sunny", "temperature": 28},
            {"day": 2, "condition": "Partly Cloudy", "temperature": 25},
            {"day": 3, "condition": "Rainy", "temperature": 20}
        ][:days]
    }
`;


================================================
FILE: src/utils/modelOptions.js
================================================
export const modelOptions = [
  {
    value: "gpt-4o",
    label: "GPT-4o",
    description: "Most capable model for a wide range of tasks (default)"
  },
  {
    value: "o3-mini",
    label: "O3-mini",
    description: "Faster and more cost-effective model for simpler tasks"
  },
  {
    value: "gpt-4o-mini",
    label: "GPT-4o-mini",
    description: "Smaller, faster version of GPT-4o"
  }
];

export const modelSettingsDefaults = {
  temperature: 0.7,
  topP: 1,
  frequencyPenalty: 0,
  presencePenalty: 0,
  maxTokens: 4096
};


================================================
FILE: src/utils/tools.js
================================================
export const builtInTools = [
  {
    id: 'websearch',
    name: 'WebSearchTool',
    description: 'Search the web for information',
    category: 'Built-in',
    parameters: {}
  },
  {
    id: 'filesearch',
    name: 'FileSearchTool',
    description: 'Search through vector stores of documents',
    category: 'Built-in',
    parameters: {
      max_num_results: 3,
      vector_store_ids: []
    }
  }
];

export const exampleFunctionTools = [
  {
    id: 'weather',
    name: 'get_weather',
    description: 'Get weather information for a city',
    category: 'Function',
    parameters: {
      city: {
        type: 'string',
        description: 'The city to get weather for'
      }
    },
    code: `@function_tool
def get_weather(city: str) -> str:
    """Fetch weather for a city.
    
    Args:
        city: The city to get weather for.
    """
    # Implementation
    return f"The weather in {city} is sunny"`
  },
  {
    id: 'calculator',
    name: 'calculate',
    description: 'Perform a calculation',
    category: 'Function',
    parameters: {
      expression: {
        type: 'string',
        description: 'The mathematical expression to evaluate'
      }
    },
    code: `@function_tool
def calculate(expression: str) -> str:
    """Evaluate a mathematical expression.
    
    Args:
        expression: The expression to evaluate.
    """
    # Implementation with proper sanitization
    try:
        result = eval(expression, {"__builtins__": {}}, {"sin": math.sin, "cos": math.cos})
        return f"Result: {result}"
    except Exception as e:
        return f"Error: {str(e)}"`
  }
];


================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

**IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Environment (please complete the following information):**
 - OS: [e.g. Windows, macOS, Linux]
 - Browser: [e.g. Chrome, Firefox, Safari]
 - Version: [e.g. 22]
 - Node.js version: [e.g. 14.17.0]
 - npm version: [e.g. 6.14.13]

**Additional context**
Add any other context about the problem here.


================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

**IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**How would this feature benefit most users?**
Explain how this feature would improve the experience for most users of the application.

**Additional context**
Add any other context or screenshots about the feature request here.


================================================
FILE: .github/PULL_REQUEST_TEMPLATE/pull_request_template.md
================================================
**IMPORTANT**: This project is created by J. Gravelle (https://j.gravelle.us | j@gravelle.us) and is **not affiliated with, endorsed by, or sponsored by OpenAI**. It is an independent tool designed to work with the OpenAI Agents SDK.

## Description
<!--- Describe your changes in detail -->

## Related Issue
<!--- If fixing a bug, there should be an issue describing it with steps to reproduce -->
<!--- Please link to the issue here: -->
Fixes #

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->

## How Has This Been Tested?
<!--- Please describe in detail how you tested your changes. -->
<!--- Include details of your testing environment, and the tests you ran to -->
<!--- see how your change affects other areas of the code, etc. -->

## Screenshots (if appropriate):

## Types of changes
<!--- What types of changes does your code introduce? Put an `x` in all the boxes that apply: -->
- [ ] Bug fix (non-breaking change which fixes an issue)
- [ ] New feature (non-breaking change which adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to change)

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] My change requires a change to the documentation.
- [ ] I have updated the documentation accordingly.
- [ ] I have read the **CONTRIBUTING.md** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.

